\input texinfo.tex    @c -*-texinfo-*-
@c
@c %**start of header

@c All text is ignored before the setfilename.
@setfilename cbase.info
@settitle cbase

@set edition 1.4
@set update-month Apr 2025
@set update-date 25 @value{update-month}
@set subtitle-text A C Foundation Library
@set author-text Mark A.@: Lindner

@comment %**end of header

@dircategory Software libraries
@direntry
* cbase: (cbase).               A C Foundation Library
@end direntry

@tex
\global\emergencystretch = .3\hsize
@end tex

@setchapternewpage odd

@titlepage

@title cbase
@subtitle @value{subtitle-text}
@subtitle Version @value{edition}
@subtitle @value{update-date}

@author @value{author-text}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1994-2025  Mark A Lindner

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

@end titlepage

@c Give the HTML output a title page that somewhat resembles the printed one
@ifhtml
@html
<hr noshade size=6 color="black">
<div align=right>@value{subtitle-text}<br>
Version @value{edition}<br>
@value{update-date}</div>
<br><br><br><br>
<font size=+1>@value{author-text}</font>
<hr size=3 noshade color="black">
<br><br>
@end html
@end ifhtml

@contents

@ifnottex
@node Top
@comment  node-name,  next,  previous,  up
@top cbase
@end ifnottex

@menu
* Overview of cbase::
* Types Macros and Constants::
* System Functions::
* Utility Functions::
* Data Structure Functions::
* Real-Time Scheduler Functions::
* IPC Functions::
* Networking Functions::
* Library Information Functions::
* References::
* License::
* Function Index::
* Type Index::
* Symbol Index::
@end menu

@node Overview of cbase, Types Macros and Constants, Top, Top
@comment  node-name,  next,  previous,  up
@menu
* Using cbase::
* API Conventions::
* Reentrancy and Threading::
* Portability Notes::
@end menu
@chapter Overview of cbase

@dfn{Cbase} is a library that aims to simplify systems software
development under UNIX. The library consists of several groups of
functions and macros that simplify such common tasks as memory
allocation, string parsing, subprocess execution, filesystem traversal,
and so on.

In addition, the library includes efficient implementations of some
common data structures, such as linked lists, queues, and hash tables,
as well as other less common data structures. Many of these types of
tasks involve tricky pointer arithmetic and memory management and are
inherently error-prone. Moving this common logic into a library frees
the developer from having to recode and debug this functionality each
time it is needed.

Finally, the library provides a simple, high-level interface to several
UNIX IPC mechanisms, including semaphores, shared memory, and Berkeley
sockets.

The following chapters describe all of the datatypes, constants, macros,
and functions in the library in detail. Function and datatype indices
are provided at the end of the manual.

@node Using cbase, API Conventions, , Overview of cbase
@comment  node-name,  next,  previous,  up
@section Using cbase

The @i{cbase} library exists in two configurations (the multi-threaded
configuration and the non-threaded configuration) and two forms (a
static library and a shared library), for a total of four versions. The
single-threaded versions are named @file{libcbase.a} and @file{libcbase.so},
and the multi-threaded versions are named @file{libcbase_mt.a} and
@file{libcbase_mt.so}.

Therefore, to link with the single-threaded version of the @i{cbase}
library, issue a command such as:

@example
gcc file1.o file2.o -o myprogram -lcbase
@end example

And similarly, to link with the multi-threaded version:

@example
gcc file1.o file2.o -o myprogram -lcbase_mt
@end example

If your program uses the networking functions, you may need to
link with additional libraries. No additional libraries are required
for GNU/Linux. For Solaris, the @i{socket} and @i{nsl} libraries are
required, e.g.:

@example
gcc file1.o file2.o -o myprogram -lcbase -lsocket -lnsl
@end example

It is extremely important that multi-threaded programs @i{only} be
linked with the multi-threaded version of the library, and that
single-threaded programs @i{only} be linked with the non-threaded
version. Other combinations will produce undefined behavior in your
programs.

On some systems, if both shared and static versions of a given library
are present (as they are with cbase), the linker selects the shared
library by default, producing a dynamically linked executable. When a
program is linked in this way, all library dependencies must be
specified at link time, so that the linker can generate all of the
necessary library stubs in the executable. Since the cbase library
contains references to functions that are typically defined in various
system libraries, those libraries must be explicitly linked into your
program. This list varies by operating system, but typically includes
@i{crypt} (the crypto library), @i{rt} (the POSIX real-time library),
and @i{dl} (the dynamic runtime linker library).

It is possible to force the linker to link against static libraries,
producing a statically linked executable. The appropriate switches vary
across linkers and operating systems. If you're using @b{gcc}, you can
use the @b{-static} switch to accomplish this. For example:

@example
gcc -static file1.o file2.o -o myprogram -lcbase
@end example

You can simplify the compiling and linking process, particularly for
static linking, by using the @b{pkg-config} utility (version 0.20 or
newer) to produce the appropriate preprocessor and linker flags for
cbase. Make sure the environment variable @samp{PKG_CONFIG_PATH} is
defined to include the absolute path to the @file{lib/pkgconfig}
directory beneath the cbase installation directory. Then, you can
compile a program that uses cbase as follows:

@example
gcc -static file1.c file2.c -o myprogram \
  `pkg-config --cflags --libs --static libcbase`
@end example

Substitute @samp{libcbase_mt} for @samp{libcbase} above when linking with
the multithreaded version of the library. Omit the @samp{-static} and
@samp{--static} switches if dynamic linking is desired. The backquoted
expression will evaluate to a list of all necessary preprocessor and
linker flags, including flags for any additional system libraries that
are required.

All of the definitions in the library can be made available in your
source code by including the master header file @file{cbase/cbase.h}.

@node API Conventions, Reentrancy and Threading, Using cbase, Overview of cbase
@comment  node-name,  next,  previous,  up
@section API Conventions

This section describes the naming and calling conventions for constants,
macros, datatypes, and functions in the @i{cbase} library.

All functions and macros begin with the prefix @samp{C_}.

All constants begin with the prefix @samp{C_}, with the following
exceptions: @code{TRUE}, @code{FALSE}, @code{NUL}, and @code{CRLF}.

All datatypes begin with the prefix @samp{c_} and end with the suffix
@samp{_t}, with the following exception: @i{uint_t}.

Unless their fields are expressly documented, all datatypes which begin
with the prefix @samp{c_} should be considered @dfn{opaque}. This means
that pointers to these datatypes serve only as ``handles'' which are
passed to and returned by the functions which operate on those
datatypes. The caller should never directly modify these datatypes or
the fields of the data structures that they represent. The internal
layout of these data structures may change in future versions of the
library; manipulating them only through API calls will ensure that your
code will continue to compile and function properly.

Most functions which return a pointer will by convention return
@code{NULL} on failure.

@vindex TRUE
@vindex FALSE

Functions which return a boolean (@i{c_bool_t}) or an integer will by
convention return @code{TRUE} or a nonzero value to indicate success and
@code{FALSE} or 0 to indicate failure. Note that this is different
from the typical UNIX convention of returning @code{0} on success and a
nonzero value (typically @code{-1}) on failure. Since @code{TRUE} is
defined as a nonzero value and @code{FALSE} is defined as @code{0}, the
following forms are equivalent:

@example
if(C_system_cdhome() == FALSE)
  puts("Failed.");
@end example

@sp 1

@example
if(! C_system_cdhome())
  puts("Failed.");
@end example

@node Reentrancy and Threading, Portability Notes, API Conventions, Overview of cbase
@comment  node-name,  next,  previous,  up
@section Reentrancy and Threading

With some exceptions (as documented), the functions in the @i{cbase}
library are reentrant. This means that they can be safely accessed from
concurrent threads without the need for explicit synchronization.

However, calls to functions which manipulate data structures (such as
linked lists, hash tables, and string buffers) must be synchronized by
the caller in such a way that only one thread is modifying the data
structure at any given time. For example, an insert into a linked list
by one thread with a concurrent insert (or some other operation) on the
same linked list by another thread might result in corruption of the
data structure.

In most cases, it is necessary to use reader/writer locks to ensure that
a reader (a thread that is accessing but not modifying the data
structure) does not access the data structure while another thread is
modifying it.

@node Portability Notes, , Reentrancy and Threading, Overview of cbase
@comment  node-name,  next,  previous,  up
@section Portability Notes

This version of the library works with recent versions of GNU/Linux
and MacOS. It may work on other UNIX-based or UNIX-like platforms
(e.g, Solaris, IRIX), but it has not been tested on such platforms for
many years, on account of the general obsolescence of those platforms.

The real-time scheduler is based on the POSIX.4 real-time signal
facility. At the time this code was written, this facility was only
available on Solaris; it was broken on GNU/Linux and was not available at
all on OS X. On the latter platforms, the event loop in the
multi-threaded version of the library is therefore implemented using
@code{nanosleep()} instead.

@node Types Macros and Constants, System Functions, Overview of cbase, Top
@comment  node-name,  next,  previous,  up
@menu
* Basic Types::
* Convenience Macros::
* Miscellaneous Constants::
@end menu
@chapter Types, Macros and Constants

This chapter describes convenience types, macros, and constants. These are
defined in the header @file{cbase/defs.h}.

@node Basic Types, Convenience Macros, , Types Macros and Constants
@comment  node-name,  next,  previous,  up
@section Basic Types

@tindex c_bool_t
The type @i{c_bool_t} represents a boolean value that (by convention)
can take on the values @code{TRUE} or @code{FALSE}; these are macros
defined to be @code{(1)} and @code{(0)}, respectively.

@tindex c_byte_t
The type @i{c_byte_t} represents an unsigned 8-bit value (0 - 255).

@tindex uint_t
The type @i{uint_t} represents an unsigned integer.

@node Convenience Macros, Miscellaneous Constants, Basic Types, Types Macros and Constants
@comment  node-name,  next,  previous,  up
@section Convenience Macros

The following convenience macros are provided:

@defmac C_max (a, b)
@defmacx C_min (a, b)
@defmacx C_sgn (a)

The first two macros correspond to the mathematical @i{max} and @i{min}
functions. @code{C_max()} returns @var{a} if @var{a} > @var{b} and
@var{b} otherwise. @code{C_min()} returns @var{a} if @var{a} < @var{b}
and @var{b} otherwise. The third macro corresponds to the mathematical
@i{sgn} function. It returns @code{-1} if @var{a} < 0, @code{1} if
@var{a} > 0, or @code{0} if @var{a} == 0.  Note that these macros may
evaluate their arguments more than once, so they should not be applied
to expressions that have side-effects (e.g., ``@code{b++}'').

@end defmac

@defmac C_bit_set (i, b)
@defmacx C_bit_clear (i, b)
@defmacx C_bit_isset (i, b)

These macros set, clear, and test the @var{b}'th bit of @var{i} (which
is presumably an integer) using bitwise operators. Each evaluates its
arguments only once.

@end defmac

@defmac C_offsetof (type, element)

This macro returns the offset, in bytes, of the element named
@var{element} in the aggregate type @var{type} (which is presumably a
@i{struct}). It works similarly to the X11 macro @code{XtOffsetOf()}.

@end defmac

@defmac C_lengthof (array)

This macro returns the length of (the number of elements in) the array
@var{array}, which is assumed to be a stack-allocated array. If
@var{array} is a pointer, the results are undefined.

@end defmac

@node Miscellaneous Constants, , Convenience Macros, Types Macros and Constants
@comment  node-name,  next,  previous,  up
@section Miscellaneous Constants

The header file also defines the following constants:

@vindex NUL
@vindex CRLF
@table @code
@item NUL
The @b{NUL} character (ASCII value 0); not to be confused with
@code{NULL}, the @i{NULL} pointer, a constant that is defined in
@file{stdio.h}.

@item CRLF
The string @code{"\r\n"}, or carriage return and line feed.

@end table

@node System Functions, Utility Functions, Types Macros and Constants, Top
@comment  node-name,  next,  previous,  up
@menu
* Byte Order Conversion Functions::
* Debugging and Tracing Functions::
* Dynamic Linker Functions::
* Error Handling Functions::
* Exception Handling Functions::
* Process Control Functions::
* Filesystem Functions::
* Mandatory File Locking Functions::
* I/O Functions::
* Logging Functions::
* Memory Management Functions::
* Memory Pool Functions::
* Memory Mapped Files::
* System Information Functions::
@end menu
@chapter System Functions

This chapter describes functions involving system facilities such as
I/O, subprocess execution, error handling, and memory management. They
are divided into several groups; the functions in a group share a common
name prefix for that group; e.g., all filesystem-related functions have
names that begin with @samp{C_file_}. All of the constants, macros, and
functions described in this chapter are defined in the header
@file{cbase/system.h}.

The following sections describe each group in detail.

@node Byte Order Conversion Functions, Debugging and Tracing Functions, , System Functions
@comment  node-name,  next,  previous,  up
@section Byte Order Conversion Functions

The following functions convert various numeric types between host and
network byte order.

@deftypefun uint16_t C_byteord_htons (@w{uint16_t @var{val}})
@deftypefunx uint16_t C_byteord_ntohs (@w{uint16_t @var{val}})

These functions convert an unsigned 16-bit ``short'' integer @var{val}
to and from network byte order, respectively. The functions return the
converted value.

@end deftypefun

@deftypefun uint32_t C_byteord_htonl (@w{uint32_t @var{val}})
@deftypefunx uint32_t C_byteord_ntohl (@w{uint32_t @var{val}})

These functions convert an unsigned 32-bit ``long'' integer @var{val} to
and from network byte order, respectively. The functions return the
converted value.

@end deftypefun

@deftypefun uint64_t C_byteord_htonll (@w{uint64_t @var{val}})
@deftypefunx uint64_t C_byteord_ntohll (@w{uint64_t @var{val}})

These functions convert an unsigned 64-bit ``long long'' integer
@var{val} to and from network byte order, respectively. The functions
return the converted value.

@end deftypefun

@deftypefun float C_byteord_htonf (@w{float @var{val}})
@deftypefunx float C_byteord_ntohf (@w{float @var{val}})

These functions convert an 32-bit floating point value @var{val} to and
from network byte order, respectively. The functions return the
converted value.

@end deftypefun

@deftypefun double C_byteord_htond (@w{double @var{val}})
@deftypefunx double C_byteord_ntohd (@w{double @var{val}})

These functions convert an 64-bit double-precision floating point value
@var{val} to and from network byte order, respectively. The functions
return the converted value.

@end deftypefun

@node Debugging and Tracing Functions, Dynamic Linker Functions, Byte Order Conversion Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Debugging and Tracing Functions

The following functions are provided to aid in the debugging and tracing
of code.

@deftypefun void C_debug_printf (@w{const char *@var{format}}, ...)

@vindex DEBUG
This function is similar to @code{printf()}, and is intended for use in
generating debug output. The function is actually implemented as a macro
which evaluates to a call to an internal library function if the
@code{DEBUG} macro is defined; otherwise, it is defined as a no-op,
which essentially prevents the debug call from being compiled into the
calling code.

Debug messages are written to the debugging stream (@code{stderr} by
default). The stream is explicitly flushed after the message is written.

If tracing is enabled, the message will be preceded by the source file
name and line number of the @code{C_debug_printf()} call. In the
multi-threaded version of the library, the message will be preceded by
the calling thread's ID as well.

@end deftypefun

@deftypefun void C_debug_set_trace (@w{c_bool_t @var{flag}})
@deftypefunx void C_debug_set_stream (@w{FILE * @var{stream}})

These functions alter the behavior of the @code{C_debug_printf()}
function described above.

@code{C_debug_set_trace()} enables or disables tracing based on the
value of @var{flag}. If tracing is enabled, the filename and line number
of the @code{C_debug_printf()} call will be prepended to each line of
debug output.

@code{C_debug_set_stream()} sets the output stream for debug messages to
@var{stream}; the default stream is @code{stderr}.

@end deftypefun

@deftypefun void C_debug_set_termattr (@w{c_bool_t @var{flag}})

This function enables or disables the use of ANSI color and text style
terminal attributes for debug messages. This feature is enabled by
default, and causes all debug messages (when written to a tty) to be
printed in a bold font, and assertion failure messages in particular to
be printed in red.

@end deftypefun

@defmac C_assert (@var{expr})

This macro evaluates an assertion; it is provided as a replacement for
the more rudimentary @code{assert()} C library function. The macro works
as follows.

If the expression @var{expr} evaluates to zero (@code{0}), the assertion
fails. A message that indicates the failure and contains the text of the
expression itself is written to the debugging stream in the same manner
as with @code{C_debug_printf()}, and then the process is aborted via a
call to the @code{abort()} C library function. For all other (non-zero)
values, the macro behaves as a no-op.

@end defmac

@node Dynamic Linker Functions, Error Handling Functions, Debugging and Tracing Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Dynamic Linker Functions

@tindex c_dlobject_t

The following functions provide a means to dynamically load and unload
object files at runtime and to obtain pointers to symbols (including
variables and functions) defined in those files. These functions are
based on the @code{dlopen()}, @code{dlsym()}, and @code{dlclose()}
library functions.

The type @i{c_dlobject_t} represents a loadable object.

@deftypefun {c_dlobject_t *} C_dlobject_create (@w{const char *@var{path}})
@deftypefunx c_bool_t C_dlobject_destroy (@w{c_dlobject_t *@var{obj}})

These functions create and destroy loadable objects.
@code{C_dlobject_create()} creates a new loadable object for the object
file specifed by @var{path}. The object will be created in a non-loaded
state. The function returns a pointer to the new loadable object
structure on success, or @code{NULL} on failure.

@code{C_dlobject_destroy()} destroys the loadable object @var{obj}, if
it is not currently loaded. It returns @code{TRUE} on success and
@code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_dlobject_load (@w{c_dlobject_t *@var{obj}}, @w{c_bool_t @var{lazy}})
@deftypefunx c_bool_t C_dlobject_unload (@w{c_dlobject_t *@var{obj}})

These functions load and unload the loadable object
@var{obj}. @code{C_dlobject_load()} loads the object @var{obj} into
memory. The flag @var{lazy} specifies whether symbols will be resolved
as they are accessed (lazy relocation), or all at once when the object
is loaded. The function will fail if @var{obj} is already loaded.

@code{C_dlobject_unload()} unloads the loadable object @var{obj}. The
function will fail if @var{obj} is not currently loaded.

The functions return @code{TRUE} on success and @code{FALSE} on
failure. In the event of a load/unload failure, a linker-specific error
is stored in @var{obj} and may be accessed via
@code{C_dlobject_error()}, which is described below.

@end deftypefun

@deftypefun {void *} C_dlobject_lookup (@w{c_dlobject_t *@var{obj}}, @w{const char *@var{symbol}})

This function looks up the symbol named @var{symbol} in the loadable
object @var{obj}. It returns a pointer to the symbol on success, or
@code{NULL} on failure. In the event of a lookup failure, a
linker-specific error is stored in @var{obj} and may be accessed via
@code{C_dlobject_error()}, which is described below.

@end deftypefun

@deftypefun c_bool_t C_dlobject_isloaded (@w{c_dlobject_t *@var{obj}})

This function (which is implemented as a macro) returns @code{TRUE} if
the loadable object @var{obj} is currently loaded, and @code{FALSE}
otherwise.

@end deftypefun

@deftypefun {const char *} C_dlobject_error (@w{c_dlobject_t *@var{obj}})

In the case of a failed call to one of the dynamic linker library
functions, an error message is stored in @var{obj}; this function (which
is implemented as a macro) returns that message.

@end deftypefun

@deftypefun {const char *} C_dlobject_path (@w{c_dlobject_t *@var{obj}})

This function (which is implemented as a macro) returns the file path of
the loadable object @var{obj}.

@end deftypefun

@node Error Handling Functions, Exception Handling Functions, Dynamic Linker Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Error Handling Functions

The following functions are provided to simplify the reporting of user-
and system-level error messages to the console.

@deftypefun void C_error_init (const char *@var{progname})

A call to this function initializes the error handling routines. The
argument @var{progname} is the name of the currently executing program,
which can be obtained from the argument list as @code{argv[0]}. The
function internally stores a copy of this pointer.

@end deftypefun

@deftypefun void C_error_printf (const char *@var{format}, ...)

This function receives arguments in the same manner as the
@code{printf()} library function. It writes the program name to standard
error, then passes its arguments to the @code{vfprintf()} library
function for formatted output to standard error. It then flushes the
standard error stream.

@end deftypefun

@deftypefun void C_error_usage (const char *@var{usage})

This function prints the command-line usage information message
@var{usage} to standard error. It then flushes the standard error
stream.

@end deftypefun

@deftypefun void C_error_syserr (void)

This function is a higher-level interface to the @code{strerror()}
library function. It obtains the error code from the latest system call
executed, formats it as a string, and writes it to standard error. All
other functionality is identical to @code{C_error_printf()} above.

@end deftypefun

@deftypefun {const char *} C_error_string (void)

This function returns a textual error message for the error code from the
last-executed cbase library routine.

@end deftypefun

@deftypefun int C_error_get_errno (void)

This function returns the error code from the last-executed cbase library
routine. A return value of @code{0} by convention denotes that the last
call executed successfully (no error); note however, that most library
routines do not modify the error code at all if they complete
successfully.  In the multi-threaded version of the library, this
function returns a thread-specific error value. In the single-threaded
version, it simply returns the value of @code{c_errno}.

Calling this routine is equivalent to evaluating @code{c_errno}, which
is defined as a macro that evaluates to a call to
@code{C_error_get_errno()}.

Therefore in both single-threaded and multi-threaded code, it is safe to
call @code{C_error_get_errno()} or to evaluate @code{c_errno} as if it
were a global variable; either approach will correctly return the error
code for the current thread or process. Note that since @code{c_errno}
evaluates to a function call, it cannot be used as an lvalue; that is,
it is not possible to assign values to it.

@end deftypefun
@deftypefun void C_error_set_errno (int @var{err})

This function sets the error code for the currently executing cbase
library routine to @var{err}. This function is provided for use by cbase
extension libraries and is not intended for use by user code.

In the multi-threaded version of the library, @code{C_error_set_errno}
is defined as a function that sets a thread-specific error
value. Otherwise, it is defined as a function that simply assigns
@var{err} to the global @i{int} variable @code{c_errno}.

@end deftypefun

@node Exception Handling Functions, Process Control Functions, Error Handling Functions, Top
@comment  node-name,  next,  previous,  up
@section Exception Handling Functions

The cbase library provides a rudimentary form of exception handling built
on top of the @code{setjmp()} and @code{longjmp()} library functions. This
facility can be used to simplify error handling and avoid the use of
@code{goto} statements to skip over logic once an error is encountered.

Exceptions are @code{int} values. For improved readability, a program can
define its exceptions as a set of integer constants or as an enumeration.

@defmac C_try @{ ... @}
@defmacx C_catch (@var{variable}) @{ ... @}
@defmacx C_throw (@var{exception})

These macros implement the customary `try', `catch', and `throw' exception
handling statements.

@code{C_try} introduces a @i{try} block, which is a new scope that must
be enclosed in braces.

The @i{try} block must be followed by a @i{catch} block, which is also a
new scope that must be enclosed in braces.

@code{C_catch} takes a single argument, @var{variable}, which is the name of a
variable. Within the @i{catch} block, an @code{int} variable with that name
will be assigned to the exception value that was thrown.

@code{C_throw} throws the exception @var{exception}, which must be a
non-zero integer. (If @var{exception} is 0, the behavior is
undefined.) The stack is unwound to the topmost frame of the
@i{try} block, all remaining logic in the @i{try} block is skipped,
and control jumps to the beginning of the @i{catch} block.

Attempting to @i{throw} or @i{catch} when there is no enclosing @i{try}
block is a programming error, and results in an assertion.

The library maintains a stack of exception contexts, so @i{try}/@i{catch}
blocks can be nested to arbitrary depth.

@end defmac

@defmac C_throws (@var{exception}, ...)

This macro may be used to annotate a function with the list of exceptions
that it can potentially throw. This macro has no behavior; it is simply
used as a documentation aid. For example:

@example
extern int some_function(int arg) C_throws(FILE_ERROR, IO_ERROR);
@end example

@end defmac

The following code snippet illustrates the use of the exception handling
macros. Note that in this example, the @code{open_file()} and
@code{read_int_from_file()} functions, which are defined elsewhere, can
potentially throw exceptions. Note also that in the case of an exception,
the file still must be closed in the @i{catch} block to avoid a resource
leak.

@example
const int FILE_ERROR = 1;
const int IO_ERROR = 2;
const int BAD_VALUE_ERROR = 3;

extern FILE *open_file(const char *path) C_throws(FILE_ERROR);
extern int read_int_from_file(FILE *fp) C_throws(IO_ERROR);
extern void close_file(FILE *fp);

C_try
@{
  FILE *fp;
  int x;

  fp = open_file("./data.txt");

  x = read_int_from_file(fp);
  if (x <= 0)
    C_throw(BAD_VALUE_ERROR);

  close_file(fp);
@}
C_catch(exc)
@{
  close_file();

  switch (exc)
  @{
    case FILE_ERROR:
      printf("File error occurred.\n");
      break;
    case IO_ERROR:
      printf("I/O error occurred.\n");
      break;
    case BAD_VALUE_ERROR:
      printf("Invalid value read from file.\n");
   @}
@}
@end example

@node Process Control Functions, Filesystem Functions, Error Handling Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Process Control Functions

The following functions provide subprocess control, including
higher-level interfaces to system calls such as @code{execv()}, and
piping.

@deftypefun int C_exec_run (char **@var{argv}, int @var{fdin}, int @var{fdout}, @w{c_bool_t @var{waitf}})
@deftypefunx int C_exec_run_cwd (char **@var{argv}, int @var{fdin}, int @var{fdout}, @w{c_bool_t @var{waitf}}, @w{const char *@var{cwd}})

@code{C_exec_run()} is a higher-level interface to the @code{execv()}
system call. It executes the command specified by @var{argv} as a
subprocess, connecting its standard input stream to the @var{fdin} file
descriptor (or to @file{/dev/null} if @var{fdin} is negative) and its
standard output and standard error streams to the @var{fdout} file
descriptor (or to @file{/dev/null} if @var{fdout} is negative). If
@var{waitf} is @code{TRUE}, the function additionally performs a
@code{waitpid()} system call to wait for the subprocess to finish
executing.

@code{C_exec_run_cwd()} is identical to @code{C_exec_run()}, except that
the additional argument @var{cwd} specifies a new working directory for
the spawned subprocess. If this path does not exist or is not readable,
the working directory of the subprocess will remain unchanged.

If @var{waitf} is @code{TRUE}, the functions return the exit value from
the subprocess. Otherwise, they return @code{0} on success or @code{-1}
on failure.

@end deftypefun

@deftypefun int C_exec_va_run (@w{int @var{fdin}}, @w{int @var{fdout}}, @w{c_bool_t @var{waitf}}, @w{... /* , NULL */})
@deftypefunx int C_exec_va_run_cwd (@w{int @var{fdin}}, @w{int @var{fdout}}, @w{c_bool_t @var{waitf}}, @w{const char *@var{cwd}}, @w{... /* , NULL */})

These are variable argument list versions of @code{C_exec_run()} and
@code{C_exec_run_cwd()}. The command name and arguments are passed as a
@code{NULL}-terminated list of @i{char *} arguments rather than as a
string vector. The other arguments have the same meaning as in
@code{C_exec_run()} and @code{C_exec_run_cwd()}, and the functionality
is identical.

@end deftypefun

@deftypefun int C_exec_pipefrom (char **@var{argv}, int *@var{fd})
@deftypefunx int C_exec_pipefrom_cwd (char **@var{argv}, int *@var{fd}, @w{const char *@var{cwd}})

@code{C_exec_pipefrom()} executes the command specified by @var{argv} as a
subprocess, redirecting its standard input stream to @file{/dev/null},
and connecting its standard output and standard error streams to a new
file descriptor whose value is stored at @var{fd}. It returns
immediately after forking the subprocess. Subsequent reads from the file
descriptor at @var{fd} will effect a piping of output from the
subprocess into the caller.

@code{C_exec_pipefrom_cwd()} is identical to @code{C_exec_pipefrom()},
except that the additional argument @var{cwd} specifies a new working
directory for the spawned subprocess. If this path does not exist or is
not readable, the working directory of the subprocess will remain
unchanged.

The functions return @code{0} on success, or @code{-1} on failure.

The following code illustrates the use of @code{C_exec_pipefrom()} to
process the output from an execution of the @code{ls} program.

@example
int fd, r;
char buf[100], **args;
FILE *fp;

args = C_string_va_makevec(NULL, "/bin/ls", "-al",
                           "/usr/local/bin", NULL);
r = C_exec_pipefrom(args, &fd);
if(r != -1)
@{
  fp = fdopen(fd, "r");
  while(C_io_gets(fp, buf, sizeof(buf), '\n') != EOF)
    printf("Received: %s\n", buf);
  fclose(fp);
@}

C_free_vec(args);
@end example

@end deftypefun

@deftypefun int C_exec_pipeto (char **@var{argv}, int *@var{fd})
@deftypefunx int C_exec_pipeto_cwd (char **@var{argv}, int *@var{fd}, @w{const char *@var{cwd}})

@code{C_exec_pipeto()} executes the command specified by @var{argv} as a
subprocess, redirecting its standard output and standard error streams
to @file{/dev/null}, and connecting its standard input stream to a new
file descriptor whose value is stored at @var{fd}. It returns
immediately after forking the subprocess. Subsequent writes to the file
descriptor at @var{fd} will effect a piping of input into the subprocess
from the caller.

@code{C_exec_pipeto_cwd()} is identical to @code{C_exec_pipeto()},
except that the additional argument @var{cwd} specifies a new working
directory for the spawned subprocess. If this path does not exist or is
not readable, the working directory of the subprocess will remain
unchanged.

The functions return @code{0} on success, or @code{-1} on failure.

@end deftypefun 

@deftypefun int C_exec_va_call (const char *@var{arg}, @w{... /* , NULL */})

This function is intended for use as a replacement for the unsafe
@code{system()} library function. It executes in a subprocess the
command specified by the @code{NULL}-terminated variable argument list,
waits for the subprocess to finish, and returns the exit value returned
by the subprocess. No stream redirection takes place: the subprocess
reads from and writes to the parent's standard I/O streams. This function
is implemented using a call to @code{C_exec_run()}, which calls the
@code{execvp()} system call.

On success, the function returns the exit status from the subprocess. On
failure, it returns @code{-1}.

@end deftypefun

@deftypefun int C_exec_wait (pid_t @var{pid})

This function is an interface to the @code{waitpid()} system call. It
waits for the process with process ID of @var{pid} to complete, and
returns its exit status.

@end deftypefun

@node Filesystem Functions, Mandatory File Locking Functions, Process Control Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Filesystem Functions

The following functions provide for the manipulation of files and
directories in the UNIX filesystem.

@deftypefun c_bool_t C_file_readdir (const char *@var{path}, @w{c_dirlist_t *@var{dir}}, @w{int @var{flags}})

@tindex c_dirlist_t
This function reads the names of the files in the directory specified by
@var{path} into the directory list pointed to by @var{dir}. The type
@i{c_dirlist_t} represents a directory file list. Specific directory
reading options are specified in the @var{flags} argument, which is a
bitwise OR of the following macros:

@vindex C_FILE_SKIPDOT
@vindex C_FILE_SKIP2DOT
@vindex C_FILE_SKIPHIDDEN
@vindex C_FILE_ADDSLASH
@vindex C_FILE_SKIPDIRS
@vindex C_FILE_SKIPFILES
@vindex C_FILE_SEPARATE
@vindex C_FILE_SORT
@table @code

@item C_FILE_SKIPDOT
Specifies that the @file{.} entry (referring to the current directory)
not be included in the list.

@item C_FILE_SKIP2DOT
Specifies that the @file{..} entry (referring to the parent directory)
not be included in the list.

@item C_FILE_SKIPHIDDEN
Specifies that hidden files (those beginning with @file{.}) not be
included in the list.

@item C_FILE_ADDSLASH
Specifies that a slash (@file{/}) be appended to directory names.

@item C_FILE_SKIPDIRS
Specifies that directories not be included in the list.

@item C_FILE_SKIPFILES
Specifies that ordinary files not be included in the list.

@item C_FILE_SEPARATE
Specifies that directory names and file names be separated into two
separate lists.

@item C_FILE_SORT
Specifies that the resulting list(s) of names be sorted alphabetically.

@end table

The @i{c_dirlist_t} type is a structure that contains the following members:

@multitable @columnfractions .2 .7

@item @code{char **files}
@tab
A vector of file names (or all names, if @code{C_FILE_SEPARATE} was not
specified).
@item @code{char **dirs}
@tab
A vector of directory names (or @code{NULL}, if @code{C_FILE_SEPARATE} was
not specified).
@item @code{uint_t nfiles}
@tab
The number of regular file names read.
@item @code{uint_t ndirs}
@tab
The number of directory names read.

@end multitable

The function ignores all files which are not regular files or
directories, including symbolic links.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{path} is @code{NULL} or invalid).

@end deftypefun

@deftypefun c_bool_t C_file_traverse (const char *@var{path}, c_bool_t (*@var{examine}) (const char *file, const struct stat *fst, uint_t depth, void *hook), @w{void *@var{hook}})

This is a general purpose directory tree traversal function. It begins
descending a directory tree rooted at @var{path}, recursing on
subdirectories. For each directory or regular file encountered, it calls
the function @var{examine}() with its name, its @i{struct stat}
information, and the file's depth from the original @var{path}. If the
@var{examine}() function returns @code{TRUE}, the traversal
continues. Otherwise, if it returns @code{FALSE},
@code{C_file_traverse()} sets the working directory back to @var{path}
and returns immediately.

The pointer @var{hook} may be used to pass arbitrary context data during
the traversal. This pointer will be passed to the @var{examine}()
function on each invocation.

The @var{examine}() function should not change the current working
directory, as this will confuse the traversal routine. If changing the
working directory is unavoidable, the function should save the working
directory on entry and restore it before returning.

The function returns @code{TRUE} if the tree traversal completed
successfully. It returns @code{FALSE} if any of the arguments were
invalid, if it could not set the working directory to @var{path}, or if
@var{examine}() returned @code{FALSE} during the traversal.

The following code fragment prints an outline-style list of all of the
files and subdirectories beginning at the current working directory.

@example
c_bool_t examine(const char *file, const struct stat *fst,
               uint_t depth, void *hook)
@{
  int i;

  /* indent and print filename */
  for(i = depth * 2; (i--); putchar(' '));

  puts(file);
  return(TRUE);
@}

void outline(void)
@{
  C_file_traverse(".", examine, NULL);
@}
@end example

@end deftypefun

@deftypefun {const char *} C_file_getcwd (void)

This function is a higher-level interface to the @code{getcwd()} system
call. It calls @code{getcwd()} with an initial path buffer, and if the
buffer is too small to hold the entire path, it resizes the buffer and
tries again, @i{ad infinitum}. The function returns a
dynamically allocated string containing the current path on success, or
@code{NULL} on failure. The returned string must eventually be freed by
the caller.

@end deftypefun

@deftypefun c_bool_t C_file_issymlink (const char *@var{path})
@deftypefunx c_bool_t C_file_isdir (const char *@var{path})
@deftypefunx c_bool_t C_file_isfile (const char *@var{path})
@deftypefunx c_bool_t C_file_ispipe (const char *@var{path})

These functions return @code{TRUE} if the file specified by @var{path}
exists and is of the specified type (symbolic link, directory, regular
file, or pipe, respectively),  and @code{FALSE} otherwise.

@end deftypefun

@deftypefun c_bool_t C_file_mkdirs (@w{const char *@var{path}}, @w{mode_t @var{mode}})

This function creates all intermediate directories specified in
@var{path}. Directories will be created with the permissions specified
by @var{mode}. The function returns @code{TRUE} on success or
@code{FALSE} on failure.

@end deftypefun

@deftypefun {void *} C_file_load (@w{const char *@var{path}}, @w{size_t *@var{len}})

This function loads the entire file specified by @var{path} into
memory. The size of the file (that is, the number of bytes read) is
stored at @var{len}.

On success, the function returns a pointer to the dynamically allocated
buffer containing the data. The buffer will contain the entire contents
of the file, plus a single trailing @code{NUL} byte; this allows the
data to be interpreted as a string if the source was a text file.

On failure (for example, if @var{path} or @var{len} is @code{NULL}, or
if the file does not exist or cannot be read) the function returns
@code{NULL}.

@end deftypefun

@node Mandatory File Locking Functions, I/O Functions, Filesystem Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Mandatory File Locking Functions

The following functions implement mandatory file locks. Reader/writer
locks and simple filesystem-based semaphores can be implemented using
these functions. These functions lock and unlock entire files; finer
granularity locks may be implemented using the @code{fcntl()} system
call.

@deftypefun c_bool_t C_file_lock (FILE *@var{fp}, @w{int @var{type}})

@vindex C_FILE_READ_LOCK
@vindex C_FILE_WRITE_LOCK
This function locks an open file @var{fp}. The type of lock is specified
by @var{type} and must be one of @w{@code{C_FILE_READ_LOCK}} (for a read
lock) or @w{@code{C_FILE_WRITE_LOCK}} (for a write lock); these constants
are defined in @file{cbase/util.h}. If the file referred to by @var{fp} is
currently locked by another thread or process, this function blocks
until that lock is released.

The function returns @code{TRUE} if the lock operation succeeds, and
@code{FALSE} if it fails.

@end deftypefun

@deftypefun c_bool_t C_file_trylock (FILE *@var{fp}, @w{int @var{type}})

This function is similar to @w{@code{C_file_lock()}} above, except that if
the lock cannot be obtained, the function returns immediately with a
value of @code{FALSE}.

The function returns @code{TRUE} if the lock operation succeeds, and
@code{FALSE} if it fails.

@end deftypefun

@deftypefun c_bool_t C_file_unlock (FILE *@var{fp}, @w{int @var{type}})

This function removes the lock on the file @var{fp}. The type of lock is
specified by @var{type}, and must match the @var{type} value that was
used for the @w{@code{C_file_lock()}} or @w{@code{C_file_trylock()}}
call that established this lock.

The function returns @code{TRUE} if the unlock operation succeeds, and
@code{FALSE} if it fails.

@end deftypefun

@node I/O Functions, Logging Functions, Mandatory File Locking Functions, System Functions
@comment  node-name,  next,  previous,  up
@section I/O Functions

The following functions simplify reading from and writing to files and
obtaining input from the console.

@deftypefun int C_io_getchar (uint_t @var{delay})

This function is meant to be used as a replacement for @code{getchar()}
in interactive contexts. It accepts a single character of input from the
user by disabling all buffering and character processing on the
controlling terminal. Any character can be entered, including those that
have special meaning to the shell. The argument @var{delay} specifies
how many seconds to wait for a character to be entered.

If the delay expires before a character is typed, the function returns
@code{EOF}. Otherwise, it returns the ASCII value of the character. The
value of @var{delay} may be 0 to effect a poll of the keyboard.

@end deftypefun

@deftypefun int C_io_gets (FILE *@var{fp}, char *@var{buf}, size_t @var{bufsz}, char @var{termin})

This function is meant to be used as a replacement for the
@code{fgets()} library function. It reads data from the stream @var{fp}
into the buffer @var{buf} until @var{bufsz} - 1 bytes have been read or
the terminator character @var{termin} is encountered. Once either
condition has occurred, the input buffer is terminated with a @code{NUL}
character. The terminator character is discarded.

The function returns the number of bytes actually read, or @code{EOF} if
no more characters are available. A return value of @code{0} means that the
terminator character was the first character encountered; it does not
signify an end-of-file condition.

If @var{fp} or @var{buf} is @code{NULL}, the function returns @code{EOF}
immediately.

@end deftypefun

@deftypefun int C_io_getpasswd (@w{const char *@var{prompt}}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

This function is a general-purpose password input routine. It writes the
prompt string @var{prompt} to standard output, turns off echoing on the
controlling terminal, reads data from standard input into the buffer
@var{buf} in the same manner as @code{C_io_gets()} above, and then turns
echoing back on. The input buffer is terminated with a @code{NUL}
character. The newline terminator character is discarded.

@end deftypefun

@deftypefun {char *} C_io_getline (FILE *@var{fp}, char @var{termin}, int *@var{len})

This function is a dynamic line input routine. It reads a line of
unlimited length from the stream @var{fp}, stopping once the terminator
character @var{termin} is encountered. It allocates memory as needed to
store the data being read from the stream.

Once the terminator character is encountered, it is discarded and the
string is @code{NUL}-terminated. The number of characters read
(not including the terminator) is stored at @var{len} if it is
non-@code{NULL}.

On success, the function returns a pointer to the dynamically allocated
buffer, which is exactly large enough to hold the @code{NUL}-terminated
string. On failure (for example, on end-of-file), it returns
@code{NULL}.

@end deftypefun

@deftypefun {char *} C_io_getline_buf (FILE *@var{fp}, @w{char @var{termin}}, @w{c_buffer_t *@var{buf}})

This function is similar to @code{C_io_getline()} above, except that
the buffer specified by @var{buf} is used to store the data. This buffer
will be resized as necessary to accommodate the data read. The number of
characters read (not including the terminator) is stored in the
@code{datalen} field of the buffer @var{buf}, and may be obtained by using
the macro @code{C_buffer_datalen()}.

On success, the function returns the pointer to the data in @var{buf},
as returned by the macro @code{C_buffer_data()}. On failure (for
example, on end-of-file), it returns @code{NULL}.

@end deftypefun

@defmac C_getchar ()

@vindex C_FILE_GETCHAR_DELAY
This is a convenience macro. It evaluates to an expression involving a
call to @code{C_io_getchar()}, passing @code{C_IO_GETCHAR_DELAY} as an
argument.

@end defmac

@defmac C_gets (buf, bufsz)

This is a convenience macro. It evaluates to an expression involving a
call to @code{C_io_gets()}, passing @code{stdin} as the stream and
`@code{\n}' (newline) as the terminator character. It may be used as a
direct replacement for the @code{gets()} library function.

@end defmac

@defmac C_getline (fp, len)

This is a convenience macro. It evaluates to an expression involving a
call to @code{C_io_getline()}, passing @samp{\n} (newline) as the
terminator character.

@end defmac

@deftypefun int C_io_fprintf (@w{FILE * @var{stream}}, @w{const char *@var{format}}, @w{...})

This is a threadsafe wrapper for the @code{fprintf()} library
function. It locks @var{stream} via a call to @code{flockfile()} before
proceeding to call @code{fprintf()}, and then unlocks the stream after
that function completes. This ensures that only one thread at a time
can write to the stream.

The function returns the value returned by @code{fprintf()}. In the
single-threaded version of the library, this function simply invokes
@code{fprintf()}.

@end deftypefun

@deftypefun int C_printf (@w{const char *@var{format}}, @w{...})

This function (which is implemented as a macro) calls
@code{C_io_fprintf()}, described above, passing @code{stdout} as the
stream.

@end deftypefun

@node Logging Functions, Memory Management Functions, I/O Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Logging Functions

The following functions provide a simple, minimal API for writing log
messages to the console and/or a log file.

@deftypefun void C_log_set_console (c_bool_t @var{flag})

This function enables or disables the writing of log messages to the
console (that is, the standard error stream) based on the value of
@var{flag}. By default, log messages are written to the console.

@end deftypefun

@deftypefun void C_log_set_stream (FILE *@var{stream})

This function specifies the @var{stream} for log messages. If
@var{stream} is @code{NULL}, logging to a stream will be disabled.

@end deftypefun

@deftypefun void C_log_set_termattr (@w{c_bool_t @var{flag}})

This function enables or disables the use of ANSI color and text style
terminal attributes for log messages. This feature is enabled by
default, and causes all log messages (when written to a tty) to be
printed in a bold font, and to be color coded according to severity.

@end deftypefun

@deftypefun void C_log_info (@w{const char *@var{fmt}}, ...)
@deftypefunx void C_log_warning (@w{const char *@var{fmt}}, ...)
@deftypefunx void C_log_error (@w{const char *@var{fmt}}, ...)

These @code{printf()}-style functions write informational, warning, and
error messages, respectively, to the console and/or the logging stream.

Each message will be prefixed by the current date and time.

Messages written to the console (the standard error stream) will be
written in a bold font and color-coded to reflect the severity of the
error, assuming that the stream is a tty and that terminal attributes
are enabled.

@end deftypefun

@node Memory Management Functions, Memory Pool Functions, Logging Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Memory Management Functions

The following functions and macros simplify memory management in
C. These routines provide more convenient interfaces to the standard
@code{malloc()} family of library functions.

@deftypefun {void *} C_mem_manage (void *@var{p}, size_t @var{elemsz}, @w{c_bool_t @var{clearf}})

This is a general-purpose memory management function. It is a
higher-level interface to the @code{realloc()} library function. The
argument @var{p} is a pointer to the memory to be managed in the case of
a reallocation request, or @code{NULL} for an initial allocation
request. The new or initial size of the memory, in bytes, is specified
by @var{elemsz}. If @var{clearf} is @code{TRUE}, the newly allocated
memory is zeroed; if this is a reallocation request that increases the
size of a memory segment, the existing data is preserved and only the
additional memory is zeroed.

If the memory allocation fails, the allocation error handler (if one has
been installed) will be called. If the error handler returns
@code{TRUE}, another attempt will be made to allocate the requested
memory; otherwise, it will be assumed that the allocation request cannot
be satisfied.

The function returns a pointer to the newly allocated memory on success,
or @code{NULL} on failure.

Some of the memory management macros described below evaluate to calls
to this function.

@end deftypefun

@deftypefun void C_mem_set_errorfunc (c_bool_t (*@var{func})(void))

This function allows the user to specify a memory allocation request
failure handler. @var{func} will be called each time
@code{C_mem_manage()} fails to allocate memory. This function may return
@code{TRUE} to indicate that another attempt should be made to allocate
the memory, or @code{FALSE} to indicate that no additional memory can be
made available.

If @var{func} is @code{NULL}, any currently-installed handler is
removed. See @code{C_mem_manage()} for a description of the conditions
under which @var{func} will be called.

@end deftypefun

@deftypefun void C_mem_set_alloc_hook (void (*@var{func})(@w{const void *@var{p_old}}, @w{const void *@var{p_new}}, @w{size_t @var{len}}))

This function sets the memory allocation hook function to
@var{func}. The allocation hook will be called each time memory is
allocated, reallocated, or freed using the memory functions described in
this section, or by any of the functions in this library which perform
dynamic memory allocation. The allocation hook function may be
uninstalled by passing @code{NULL} for @var{func}. By default, there is
no allocation hook installed.

The meaning of the arguments passed to the allocation hook functions
depends on the type of memory operation that was performed, as described
below. The hook is always called @i{after} the memory operation has been
performed.

@itemize @bullet

@item
When a memory segment is being initially allocated, @var{p_old} will be
@code{NULL}, @var{p_new} will be a pointer to the new segment, and
@var{len} will be the length of the new segment.

@item
When an existing memory segment is resized (reallocated), @var{p_old}
will be the pointer to the original segment, @var{p_new} will be a
pointer to the resized segment, and @var{len} will be the new length of
the segment.

@item
When a memory segment is being freed, @var{p_old} will be a pointer to
the segment that was freed, @var{p_new} will be @code{NULL}, and
@var{len} will be 0.

@end itemize

Never dereference the pointer @var{p_old}, as it no longer points to
allocated memory.

@end deftypefun

@deftypefun void C_mem_default_alloc_hook (@w{const void *@var{p_old}}, @w{const void *@var{p_new}}, @w{size_t @var{len}})

This function is a default memory allocation hook function which writes
an informational log message for each memory allocation using
@code{C_log_info()}.

@end deftypefun

@deftypefun {void *} C_mem_free (void *@var{p})

This function is simply an interface to the @code{free()} library
function. If @var{p} is not @code{NULL}, it is passed to
@code{free()}. The function always returns @code{NULL}.

@end deftypefun

@deftypefun void C_mem_freevec (char **@var{v})

This function frees a @code{NULL}-terminated character string vector
@var{v}, by first dereferencing and freeing each character array in
turn, and then freeing the character pointer array itself.

@end deftypefun

@deftypefun uint_t C_mem_va_free (uint_t @var{n}, ...)

This function is a variable-argument interface to the @code{free()}
library function. The argument @var{n} specifies how many pointers
(which must be of type @i{void *}) are being passed. Each subsequent
non-@code{NULL} argument is passed to @code{free()}.

The function returns the number of non-@code{NULL} arguments that were
processed.

@end deftypefun

@deftypefun size_t C_mem_defrag (void *@var{p} size_t @var{elemsz}, size_t @var{len}, c_bool_t (*@var{isempty})(void *elem))

This is a general-purpose memory defragmentation routine. It interprets
the memory at @var{p} as an array of @var{len} elements, each
@var{elemsz} bytes in size. @var{isempty} is a pointer to a function
which, when passed a pointer to one of the elements in the array,
determines if it is ``used'' or ``empty'' and returns @code{FALSE} or
@code{TRUE}, respectively.

The function iterates through the elements in the array, testing each
element using @var{isempty}(), and moving contiguous blocks of ``used''
elements toward the beginning of the array until all ``free'' space has
been coalesced at the end. The order of the elements within the array is
preserved.

The function returns the number of ``used'' elements in the array. This
return value can be used in a subsequent call to one of the memory
allocation routines to reduce the size of the defragmented array to
allow the unused space to be reclaimed by the system.

@end deftypefun

@defmac C_malloc (n, type)
@defmacx C_calloc (n, type)

These macros are convenient replacements for the @code{malloc()} and
@code{calloc()} library functions. They take as arguments the number of
elements to allocate @var{n}, and the element's @var{type} (such as
@i{int} or @i{struct foobar}). They return a properly cast pointer to
the memory. Hence, the call:

@example
C_malloc(5, char *)
@end example

would have a return value of type @i{char **}, that is, a pointer to 5
contiguous character pointers.

@code{C_calloc()} is similar, except that it additionally zeroes the
newly allocated memory. Both macros evaluate to expressions involving
calls to @code{C_mem_manage()}.

@end defmac

@defmac C_realloc (p, n, type)

This macro is a convenient replacement for the @code{realloc()} library
function. It takes as arguments a pointer @var{p} (of any type), the
number of elements to allocate @var{n} (which is presumed to be of type
@i{size_t}), and the element's @var{type} (such as @i{int} or @i{struct
foobar}). It reallocates the memory beginning at @var{p} to the new
size, returning a properly cast pointer to the resized memory. The macro
evaluates to an expression involving a call to @code{C_mem_manage()}.

@end defmac

@defmac C_zero (p, type)
@defmacx C_zeroa (p, n, type)

These macros zero the specified memory. @code{C_zero()} zeroes the
element of type @var{type} at location @var{p}. @code{C_zeroa()} zeroes
the @var{n}-element array of type @var{type} at location @var{p}.

@end defmac

@defmac C_free (p)
@defmacx C_free_vec (v)
@defmacx C_va_free (n, ...)

These are additional convenience macros for freeing
memory. @code{C_free()} frees the memory at @var{p}, which can be a
pointer of any type. The macro is for use in place of calls to the
@code{free()} library function. It evaluates to an expression involving
a call to @code{C_mem_free()}.

@code{C_free_vec()} and @code{C_va_free()} are identical to
@code{C_mem_free_vec()} and @code{C_mem_va_free()}, respectively.

@end defmac

@defmac C_new (type)
@defmacx C_newa (n, type)
@defmacx C_newb (n)
@defmacx C_newstr (n)

These are additional convenience macros for allocating
memory. @code{C_new()} allocates space for one element of the
specified type. @code{C_newa()} allocates space for an array of
@var{n} elements of the specified type. (These are reminiscent of
@code{new} and @code{new[]} in C++.) @code{C_newb()} allocates space
for an @var{n}-byte segment. @code{C_newstr()} allocates space for a
character array of length @var{n} plus a trailing NUL.  The variable
@var{n} is assumed to be of type @i{size_t}.

These macros all expand to expressions involving the @code{C_calloc()}
macro, hence the returned memory will always be zeroed. All of these
macros return properly-cast pointers to the newly allocated memory, so
an explicit cast is not necessary. For example:

@example
char *s = C_newstr(45);
struct foobar *item = C_new(struct foobar);
int *scores = C_newa(20, int);
@end example

@end defmac

@node Memory Pool Functions, Memory Mapped Files, Memory Management Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Memory Pool Functions

@tindex c_mempool_t

The following functions provide a simple memory pool mechanism. A
@dfn{memory pool} is a block of memory allocated on the heap. The
application may allocate smaller segments of memory from this pool. When
these segments are no longer needed, they are all released at once by
deallocating the pool.

The type @i{c_mempool_t} represents a memory pool.

@deftypefun {c_mempool_t *} C_mempool_create (@w{size_t @var{size}})
@deftypefunx void C_mempool_destroy (@w{c_mempool_t *@var{pool}})

These functions create and destroy memory pools.

@code{C_mempool_create()} creates a new memory pool of the given
@var{size}, returning a pointer to the newly created pool on success,
or @code{NULL} on failure (for example, if @var{size} is less than 1,
or if the memory allocation failed). The memory in the pool is always
initially zeroed.

@code{C_mempool_destroy()} destroys the memory pool @var{pool}. All
segments allocated from the pool should no longer be accessed, as they
refer to memory that has been released.

@end deftypefun

@deftypefun {void *} C_mempool_alloc (@w{c_mempool_t *@var{pool}}, @w{size_t @var{size}})

This function allocates a memory segment @var{size} bytes in length from
the memory pool @var{pool}. It returns a pointer to the segment on
success, or @code{NULL} on failure (for example, if there is not enough
unused memory in the pool to satisfy the request). The returned pointer
will always be word-aligned, and the size of the segment returned will
be rounded up to the next multiple of the word size.

@end deftypefun

@deftypefun size_t C_mempool_avail (@w{c_mempool_t *@var{pool}})

This function returns the number of bytes available to be allocated from
the memory pool @var{pool}.

@end deftypefun

@defmac C_palloc1 (pool, type)
@defmacx C_palloc (pool, n, type)
@defmacx C_pallocstr (pool, n)

These are convenience macros for allocating memory from a memory
@var{pool}. @code{C_palloc1()} allocates space for one element of the
given @var{type}. @code{C_palloc()} allocates space for an array of
@var{n} elements of the given @var{type}. @code{C_pallocstr()} allocates
space for a string of length @var{n} - 1. The variable @var{n} is
assumed to be of type @i{size_t}.

All of these macros return properly-cast pointers to the newly allocated
memory, so an explicit cast is not necessary.
@end defmac

@node Memory Mapped Files, System Information Functions, Memory Pool Functions, System Functions
@comment  node-name,  next,  previous,  up
@section Memory Mapped Files

@tindex c_memfile_t

The following functions provide a high-level interface to memory mapped
files. A @dfn{memory mapped file} is a disk file that has been mapped
into the calling process's address space; the contents of the file may
be manipulated by modifying memory directly. This mechanism is
especially useful for very large files, as the operating system takes
care of the details of paging portions of the file in and out of memory
as needed, and of keeping the contents of the disk file in sync with the
data that is in memory.

The type @i{c_memfile_t} represents a memory mapped file.

@deftypefun {c_memfile_t *} C_memfile_open (@w{const char *@var{file}}, @w{c_bool_t @var{readonly}})

This function opens the specified @var{file} and maps it into memory. If
@var{readonly} is @code{TRUE}, the file will be mapped as read-only;
otherwise both reading and writing will be allowed.

The function returns a pointer to the new @i{c_memfile_t} structure on
success, or @code{NULL} on failure. The function @code{C_memfile_base()}
may be used to obtain a pointer to the beginning of the file in memory.

@end deftypefun

@deftypefun c_bool_t C_memfile_close (@w{c_memfile_t *@var{mf}})

This function unmaps the memory mapped file @var{mf} and closes the
file. A sync operation is performed just before the file is unmapped to
ensure that any pending updates are persisted to the disk file.

The function returns @code{TRUE} on success, or @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_memfile_sync (@w{c_memfile_t *@var{mf}}, @w{c_bool_t @var{async}})

The operating system periodically performs a sync operation to keep the
contents of the disk file up to date with the memory-resident image of
the file. This function forces such an update to take place immediately
on the memory mapped file @var{mf}. If @var{async} is @code{TRUE}, the
update is performed asynchronously, and the function returns
immediately. Otherwise, it is performed synchronously and the function
returns when the update is complete.

The function returns @code{TRUE} on success, or @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_memfile_resize (@w{c_memfile_t *@var{mf}}, @w{off_t @var{length}})

This function resizes the memory mapped file @var{mf} to the new size
@var{length}. The new length must be at least 0. If @var{length} is
smaller than the current length of the file, the file will be truncated
and the excess data will be lost. If @var{length} is larger than the
current length of the file, the file will grow to the new size, and the
extra bytes will be zeroed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure.

@end deftypefun

@deftypefun {void *} C_memfile_base (@w{c_memfile_t *@var{mf}})

This function returns a pointer to the beginning of the memory occupied
by the memory mapped file @var{mf}. It is implemented as a macro.

@end deftypefun

@deftypefun {void *} C_memfile_pointer (@w{c_memfile_t *@var{mf}}, @w{off_t @var{offset}})

This function returns a pointer to the given offset @var{offset} in the
memory mapped file @var{mf}. It is implemented as a macro.

@end deftypefun

@deftypefun off_t C_memfile_length (@w{c_memfile_t *@var{mf}})

This function returns the current length of the memory mapped file
@var{mf}. It is implemented as a macro.

@end deftypefun

@node System Information Functions, , Memory Mapped Files, System Functions
@comment  node-name,  next,  previous,  up
@section System Information Functions

The following functions provide various information about the system and
about users and groups.

@deftypefun c_bool_t C_system_ingroup (@w{const char *@var{login}}, @w{const char *@var{group}})

This function determines if the user whose login name is @var{login}
belongs to the group named @var{group}. It can be used for
authentication purposes.

The function returns @code{TRUE} if the user is a member of the named
group, or @code{FALSE} if not or upon failure (for example, if either
argument is @code{NULL} or an empty string).

@end deftypefun

@deftypefun {c_sysinfo_t *} C_system_getinfo (void)

@tindex c_sysinfo_t

This function obtains various types of information about the system, the
current process and user, the terminal line, and the system time. The
function stores the information in a static data structure, to which it
returns a pointer. The @i{c_sysinfo_t} structure has the following
members:

@multitable @columnfractions .3 .7
@item @code{char *login}
@tab The current user's login name.
@item @code{char *fullname}
@tab The current user's full name.
@item @code{char *homedir}
@tab The current user's home directory.
@item @code{char *shell}
@tab The current user's login shell.
@item @code{uid_t uid}
@tab The process's real user ID.
@item @code{gid_t gid}
@tab The process's real group ID.
@item @code{uid_t euid}
@tab The process's effective user ID.
@item @code{gid_t egid}
@tab The process's effective group ID.
@item @code{char *hostname}
@tab The hostname.
@item @code{char *osname}
@tab The operating system name.
@item @code{char *osver}
@tab The OS version.
@item @code{char *osrel}
@tab The OS release.
@item @code{char *arch}
@tab The system's architecture type.
@item @code{pid_t pid}
@tab The process ID.
@item @code{pid_t ppid}
@tab The parent process ID.
@item @code{time_t stime}
@tab The system time at which this function was first called.
@item @code{char *term}
@tab The terminal line for the current process.
@end multitable

The first time the function is called, it fills the static data
structure with values retrieved from the system. Subsequent calls
immediately return the pointer to this structure.

@end deftypefun

@deftypefun uid_t C_system_get_uid (void)
@deftypefunx gid_t C_system_get_gid (void)
@deftypefunx pid_t C_system_get_pid (void)
@deftypefunx {char *} C_system_get_login (void)
@deftypefunx {char *} C_system_get_fullname (void)
@deftypefunx {char *} C_system_get_homedir (void)
@deftypefunx {char *} C_system_get_hostname (void)
@deftypefunx {char *} C_system_get_term (void)

These are convenience functions that retrieve some of the more
interesting values from the static @i{c_sysinfo_t} structure.

@end deftypefun

@deftypefun c_bool_t C_system_cdhome (void)

This function attempts to set the current working directory to the
current user's home directory. It obtains the home directory path via a
call to @code{C_system_get_homedir()}.

The function returns @code{TRUE} on success, or @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_system_passwd_generate (@w{const char *@var{passwd}}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

This function generates an encrypted password using the standard UNIX
@code{crypt()} function. The string @var{passwd} is encrypted using a
randomly generated salt, and up to @var{bufsz} - 1 bytes of the
resulting ciphertext (the first two bytes of which are the salt) are
written to the buffer @var{buf}, which is unconditionally
@code{NUL}-terminated.

The function returns @code{TRUE} on success. On failure (for example, if
@var{passwd} or @var{buf} is @code{NULL}, or if @var{bufsz} is 0) the
function returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_system_passwd_validate (@w{const char *@var{plaintext}}, @w{const char *@var{ciphertext}})

This function validates a plaintext password against the encrypted form
of the password using the standard UNIX @code{crypt()} routine. The
string @var{plaintext} is encrypted using the first two bytes of
@var{ciphertext} as the salt. If the resulting ciphertext matches
@var{ciphertext}, the function returns @code{TRUE}. If the ciphertext
strings do not match, or upon failure (for example, if either of the
arguments is @code{NULL}) it returns @code{FALSE}.

@end deftypefun

@node Utility Functions, Exception Handling Functions, System Functions, Top
@comment  node-name,  next,  previous,  up
@menu
* Bitstring Functions::
* Data Buffer Functions::
* Hexadecimal Encoding Functions::
* Random Number Functions::
* String Manipulation and Parsing Functions::
* String Buffer Functions::
* Time Functions::
* CPU Timer Functions::
* String Vector Functions::
@end menu
@chapter Utility Functions

This chapter describes various utility functions. They are divided into
several groups; the functions in a group share a common name prefix for
that group; e.g., all string-related functions have names that begin
with @samp{C_string_}. All of the constants, macros, and functions
described in this chapter are defined in the header
@file{cbase/util.h}.

The following sections describe each group in detail.

@node Bitstring Functions, Data Buffer Functions, , Utility Functions
@comment  node-name,  next,  previous,  up
@section Bitstring Functions

@tindex c_bitstring_t

The following functions provide for the manipulation of @dfn{bit
strings} of arbitrary length. Bit strings may be used to efficiently
store groups of related boolean (on/off) flags; each 8-bit byte can
represent 8 such flags.

The type @i{c_bitstring_t} represents a bit string.

@deftypefun {c_bitstring_t *} C_bitstring_create (uint_t @var{nbits})
@deftypefunx c_bool_t C_bitstring_destroy (c_bitstring_t *@var{bs})

These functions create and destroy bit strings.
@w{@code{C_bitstring_create}} creates a new bit string @var{nbits} in
length. The function returns a pointer to the newly created bit string
on success. On failure, it returns @code{NULL} (for example, if
@var{nbits} < 1).

@code{C_bitstring_destroy()} destroys the bit string @var{bs}, freeing
all memory associated with the bit string. It returns @code{TRUE} on
success, or @code{FALSE} on failure (for example, if @var{bs} is
@code{NULL}.)

@end deftypefun

@deftypefun c_bool_t C_bitstring_set (c_bitstring_t *@var{bs}, @w{uint_t @var{bit}})
@deftypefunx c_bool_t C_bitstring_clear (c_bitstring_t *@var{bs}, @w{uint_t @var{bit}})

These functions set and clear the bit at offset @var{bit} in the bit
string @var{bs}. @w{@code{C_bitstring_set()}} sets the specified @var{bit},
and @w{@code{C_bitstring_clear()}} clears it.

The functions return @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{bs} is @code{NULL} or @var{bit} is out of range).

@end deftypefun

@deftypefun c_bool_t C_bitstring_set_range (c_bitstring_t *@var{bs}, @w{uint_t @var{sbit}}, @w{uint_t @var{ebit}})
@deftypefunx c_bool_t C_bitstring_clear_range (c_bitstring_t *@var{bs}, @w{uint_t @var{sbit}}, @w{uint_t @var{ebit}})

These functions set or clear a range of bits in the bit string
@var{bs}. @code{C_bitstring_set_range()} sets all of the bits from
offsets @var{sbit} to @var{ebit},
inclusive. @code{C_bitstring_clear_range()} clears all of the bits from
offsets @var{sbit} to @var{ebit}, inclusive.

The functions return @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{bs} is @code{NULL}, if @var{sbit} or @var{ebit} is
out of range, or if @var{ebit} < @var{sbit}).

@end deftypefun

@deftypefun c_bool_t C_bitstring_set_all (c_bitstring_t *@var{bs})
@deftypefunx c_bool_t C_bitstring_clear_all (c_bitstring_t *@var{bs})

These functions set or clear all of the bits in the bit string
@var{bs}. @code{C_bitstring_set_all()} sets all bits in the bit string,
and @code{C_bitstring_clear_all()} clears all bits.

The functions return @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{bs} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_bitstring_isset (c_bitstring_t *@var{bs}, @w{uint_t @var{bit}})
@deftypefunx c_bool_t C_bitstring_isclear (c_bitstring_t *@var{bs}, @w{uint_t @var{bit}})

These functions test bits in the bit string
@var{bs}. @w{@code{C_bitstring_isset()}} determines if the bit at offset
@var{bit} is set, returning @code{TRUE} if so and @code{FALSE}
otherwise. @w{@code{C_bitstring_isclear()}} determines if the bit at offset
@var{bit} is cleared, returning @code{TRUE} if so and @code{FALSE}
otherwise.

The functions return @code{FALSE} upon failure (for example, if @var{bs}
is @code{NULL} or if @var{bit} is out of range).

@end deftypefun

@deftypefun c_bool_t C_bitstring_compare (@w{c_bitstring_t *@var{bs1}}, @w{c_bitstring_t *@var{bs2}})

This function compares the bit string @var{bs1} to the bit string
@var{bs2}. It returns @code{TRUE} if all of the bits that are set in
@var{bs1} are also set in @var{bs2}, and @code{FALSE} otherwise.

The function returns @code{FALSE} on failure (for example, if @var{bs1}
or @var{bs2} is @code{NULL}).

@end deftypefun

@deftypefun uint_t C_bitstring_size (c_bitstring_t *@var{bs})

This function, which is implemented as a macro, returns the size (in
bits) of the bit string @var{bs}.

@end deftypefun

@node Data Buffer Functions, Hexadecimal Encoding Functions, Bitstring Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section Data Buffer Functions

@tindex c_buffer_t

The following functions and macros are provided for the manipulation of
dynamically allocated data buffers. The type @i{c_buffer_t} represents a
data buffer. It contains the following members:

@multitable @columnfractions .2 .7
@item @code{char *buf}
@tab A pointer to the buffer.
@item @code{size_t bufsz}
@tab The size of the buffer.
@item @code{size_t datalen}
@tab The amount of data in the buffer.
@item @code{void *hook}
@tab A hook for associating arbitrary data.
@end multitable

The @i{c_buffer_t} type can be used as a convenient means of passing
sized buffers. The @code{datalen} member can be used to indicate how
much significant data is in a buffer. Arbitrary data can also be
associated with a buffer via the @code{hook} pointer.

@deftypefun {c_buffer_t *} C_buffer_create (size_t @var{bufsz})
@deftypefunx void C_buffer_destroy (c_buffer_t *@var{buf})

These functions create and destroy arbitrarily-sized data
buffers. @code{C_buffer_create()} creates a new data buffer @var{bufsz}
bytes in length; the buffer's memory is initially zeroed. The function
returns a pointer to the newly allocated buffer.

@code{C_buffer_destroy()} destroys the buffer @var{buf}, freeing both
the buffer memory and the @i{c_buffer_t} data structure itself.

@end deftypefun

@deftypefun {c_buffer_t *} C_buffer_resize (c_buffer_t *@var{buf}, @w{size_t @var{newsz}})

This function resizes the buffer @var{buf} to a new size of @var{newsz}.
bytes. The semantics are similar to that of @code{C_realloc()}: if the
new size is larger than the previous size, the additional bytes are
zeroed.

The function returns @var{buf} on success. On failure (for example, if @var{newsz} is 0), it returns @code{NULL}.

@end deftypefun

@deftypefun void C_buffer_clear (c_buffer_t *@var{buf})

This function zeroes the buffer @var{buf}.

@end deftypefun

@defmac C_buffer_data (buf)
@defmacx C_buffer_size (buf)
@defmacx C_buffer_datalen (buf)
@defmacx C_buffer_hook (buf)

These macros access the corresponding fields in the buffer structure
@var{buf}.

@end defmac

@node Hexadecimal Encoding Functions, Random Number Functions, Data Buffer Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section Hexadecimal Encoding Functions

The following functions encode data to and decode data from a 7-bit
ASCII hexadecimal representation. Each byte of data is encoded as a
two-character long representation of the hexadecimal value of the byte;
e.g., the value 0x3F will be encoded as the characters
@samp{3F}. Similarly, an ASCII string consisting of hexadecimal values
encoded in such a representation can be converted to a corresponding
array of bytes. Arbitrary data can be encoded or decoded using these
routines.

@defmac C_hex_isdigit (c)

This macro evaluates to @code{TRUE} if @var{c} is a valid hexadecimal
character (0 - 9, A - F, or a - f), or @code{FALSE} otherwise.

@end defmac

@deftypefun char C_hex_tonibble (int @var{v})
@deftypefunx int C_hex_fromnibble (char @var{c})

These routines convert nibbles (values in the range 0 to 15) to and from
an ASCII hexadecimal representation.

@code{C_hex_tonibble()} converts the value @var{v} to a corresponding
hexadecimal character: 0 - 9 or A - F. If the value of @var{v} is
outside the acceptable range for a nibble, the function returns
@code{NUL}.

@code{C_hex_fromnibble()} converts the hexadecimal character @var{c} to
a corresponding integer value between 0 and 15. If @var{c} is not a
hexadecimal digit character (as determined by the application of
@code{C_hex_isdigit()}), the function returns @code{-1}.

@end deftypefun

@deftypefun c_bool_t C_hex_tobyte (char *@var{s}, int @var{v})
@deftypefunx int C_hex_frombyte (char * const @var{s})

These routines convert bytes (values in the range 0 to 255) to and from
an ASCII hexadecimal representation.

@code{C_hex_tobyte()} stores the two-character ASCII representation of
the byte @var{v} at @var{s}. If the value of @var{v} is outside the
acceptable range for a byte, the function returns @code{FALSE};
otherwise it returns @code{TRUE}.

@code{C_hex_frombyte()} returns the numeric value of the byte whose
ASCII representation is stored at @var{s}. If the two characters at
@var{s} are not hexadecimal characters, the function returns @code{-1}.

@end deftypefun

@deftypefun c_bool_t C_hex_encode (char * const @var{data}, size_t @var{len}, @w{char * @var{s}})
@deftypefunx c_bool_t C_hex_decode (const char *@var{s}, size_t @var{len}, @w{char *@var{data}})

These routines convert arbitrary data to and from an ASCII hexadecimal
representation.

@code{C_hex_encode()} encodes @var{len} bytes beginning at @var{data}
into the corresponding hexadecimal representation. The encoding is
stored beginning at @var{s}, which must point to a buffer of at least
@var{len} * 2 bytes.

@code{C_hex_decode()} decodes @var{len} bytes of hexadecimal
representation beginning at @var{s} The decoded data is stored beginning
at @var{data}, which must point to a buffer of at least @var{len} / 2
bytes. Note that @var{len} must be a multiple of 2.

The functions return @code{TRUE} on success, or @code{FALSE} if passed
invalid arguments or data.

@end deftypefun

@node Random Number Functions, String Manipulation and Parsing Functions, Hexadecimal Encoding Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section Random Number Functions

The following functions are provided for the generation of random
numbers.

@deftypefun void C_random_seed (void)

In the single-threaded version of the library, this function seeds the
random number generator (via a call to @code{srand()}) with the sum of
the current value of the system clock and the current process ID. In the
multi-threaded version of the library, this function is a no-op since
the sequence is seeded automatically, as described below.

@end deftypefun

@deftypefun uint_t C_random (uint_t @var{n})

This function returns a random unsigned integer in the range [0,
@var{n}-1] (via a call to @code{rand()}). In the multi-threaded version
of the library, this function maintains a different random number
sequence for each calling thread; the first call to this function by a
thread seeds the random number sequence for that thread with the sum of
the current value of the system clock and the thread ID of the calling
thread.

@end deftypefun

@node String Manipulation and Parsing Functions, String Buffer Functions, Random Number Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section String Manipulation and Parsing Functions

The following functions parse and manipulate character arrays (strings).

@deftypefun {char *} C_string_clean (char *@var{s}, char @var{fillc})

This function replaces all non-printable characters in the string
@var{s} with the fill character @var{fillc}.

The function returns @var{s} on success, or @code{NULL} on failure (for
example, if @var{s} is @code{NULL} or @var{fillc} is @code{NUL}).

@end deftypefun

@deftypefun {char *} C_string_tolower (char *@var{s})

This function converts all uppercase characters in the string @var{s} to
lowercase. It returns @var{s}.

@end deftypefun

@deftypefun {char *} C_string_toupper (char *@var{s})

This function converts all lowercase characters in the string @var{s} to
uppercase. It returns @var{s}.

@end deftypefun

@deftypefun c_bool_t C_string_isnumeric (const char *@var{s})

This function determines if the string @var{s} is composed strictly of
numeric characters (0 - 9).

The function returns @code{TRUE} if @var{s} is numeric and @code{FALSE}
otherwise.

@end deftypefun

@deftypefun c_bool_t C_string_startswith (@w{const char *@var{s}}, @w{const char *@var{prefix}})

This function determines if the string @var{s} begins with the string
@var{prefix}. It returns @code{TRUE} if @var{prefix} is a prefix of
@var{s} and @code{FALSE} otherwise.

@end deftypefun

@deftypefun c_bool_t C_string_endswith (@w{const char *@var{s}}, @w{const char *@var{suffix}})

This function determines if the string @var{s} ends with the string
@var{suffix}. It returns @code{TRUE} if @var{suffix} is a suffix of
@var{s} and @code{FALSE} otherwise.

@end deftypefun

@deftypefun {char *} C_string_trim (char *@var{s})

This function trims whitespace from both ends of the string
@var{s}. That is, all whitespace up to the first non-whitespace
character in the string and all whitespace after the last non-whitespace
character in the string is discarded. The remaining text is moved so
that it is flush with the beginning of the string.

The function returns @var{s}.

@end deftypefun

@deftypefun {char **} C_string_split (char *@var{s}, const char *@var{sep}, @w{size_t *@var{len}})

This function is a higher-level interface to the @code{strtok_r()}
library function. It splits the string @var{s} into a series of ``words,''
breaking words on any combination of characters from the string
@var{sep}, as does the @code{strtok_r()} function.

On success, the number of words parsed is stored at @var{len} if it is
non-@code{NULL}, and the words are returned as a @code{NULL}-terminated
string vector, which is dynamically allocated and must eventually be
freed by the caller. On failure, @code{NULL} is returned.

@end deftypefun

@deftypefun {char *} C_string_dup (const char *@var{s})

This function is identical to the @code{strdup()} library function. It
duplicates the string @var{s} in memory and returns a pointer to the new
copy. It is provided because @code{strdup()} is not specified by the
POSIX.1 standard, and thus may not be available on all systems. This
function should be used in place of @code{strdup()} as it allocates
memory using @code{C_newstr()} rather than by calling @code{malloc()}
directly.

@end deftypefun

@deftypefun {char *} C_string_dup1 (const char *@var{s}, char @var{c})

This function duplicates the string @var{s} in memory and appends the
character @var{c} to the end of the duplicated
string. It returns a pointer to the new string on success, or
@code{NULL} on failure.

@end deftypefun

@deftypefun {char *} C_string_chop (char *@var{s}, const char *@var{termin})

This function searches the string @var{s} for the first occurrence of
any character in @var{termin} and replaces it with @code{NUL}. If no
terminator character is found, the string is left unmodified. The
function may be used to ``chop'' unneeded text from the end of a string
(such as a CR+LF pair at the end of a line read from a socket or DOS
file).

The function returns @var{s}.

@end deftypefun

@deftypefun {char *} C_string_rchop (char *@var{s}, const char *@var{termin})

This function searches the string @var{s} for the last occurrence of
any character in @var{termin} and replaces it with @code{NUL}. If no
terminator character is found, the string is left unmodified. The
function may be used to ``chop'' unneeded text from the end of a string
(such as a CR+LF pair at the end of a line read from a socket or DOS
file).

The function returns @var{s}.

@end deftypefun

@deftypefun {const char *} C_string_tokenize (@w{const char *@var{s}}, @w{const char *@var{delim}}, @w{const char **@var{ctx}}, @w{size_t *@var{len}})

This function is a non-destructive string tokenizer; it differs from
@code{strtok_r()} in that the source string is not modified. The
function searches for the next token in @var{s} that does not consist of
any characters in @var{delim}. The argument @var{ctx} is used to store
the tokenizer context. If @var{s} is @code{NULL}, tokenization resumes
from the last character analyzed; otherwise, it starts at the beginning
of @var{s}.

The function stores the length of the token at @var{len} and returns a
pointer to the beginning of the token. If no token is found, or on error
(for example, if @var{delim}, @var{ctx}, or @var{len} is @code{NULL})
the function returns @code{NULL}.

The following code snippet extracts words from a sentence:

@sp 1
@example
const char *text = "How now, brown cow?";
const char *ctx, *word;
uint_t len;

for(word = C_string_tokenize(text, " .,?!", &ctx, &len);
    word;
    word = C_string_tokenize(NULL, " .,?!", &ctx, &len))
@{
  printf("Word found: %.*s\n", len, word);
@}
@end example

@end deftypefun

@deftypefun c_bool_t C_string_copy (char *@var{buf}, size_t @var{bufsz}, @w{const char *@var{s}})

This function performs a safe string copy. At most @var{bufsz} - 1
characters from @var{s} are copied to @var{buf}; the string @var{buf} is
unconditionally @code{NUL}-terminated.

The function returns @code{TRUE} if the entire string @var{s} was copied
to @var{buf}; otherwise it returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_string_va_copy (char *@var{buf}, size_t @var{bufsz}, @w{... /* , NULL */})

This is a variable argument list version of the @code{C_string_copy()}
function. It copies the first string into @var{buf}, and then
concatenates all of the remaining strings (if any) onto the text already
in @var{buf}. At most @var{bufsz} - 1 total bytes are copied to
@var{buf}; the string @var{buf} is unconditionally
@code{NUL}-terminated.

The function returns @code{TRUE} if all of the strings were completely
copied to @var{buf}; otherwise it returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_string_concat (@w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{const char *@var{s}})

This function performs a safe string concatenation. It concatenates as
much of the string @var{s} onto the string @var{buf} as is possible
without overflowing @var{buf}. The resulting string will be at most
@var{bufsz} - 1 characters in length, and will be unconditionally
@code{NUL}-terminated.

The function returns @code{TRUE} if the entire string @var{s} was
concatenated onto @var{buf}; otherwise it returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_string_va_concat (@w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{... /* , NULL */})

This is a variable argument list version of the @code{C_string_concat()}
function. It concatenates each string onto the text that is already in
@var{buf}, without overflowing @var{buf}.  The resulting string will be
at most @var{bufsz} - 1 characters in length, and will be
unconditionally @code{NUL}-terminated.

The function returns @code{TRUE} if all of the strings were completely
copied to @var{buf}; otherwise it returns @code{FALSE}.

@end deftypefun

@deftypefun {char **} C_string_sortvec (char **@var{v}, size_t @var{len})

This function quicksorts the string vector @var{v}. It performs a call
to the @code{qsort()} library function to accomplish the alphabetical
sorting. The argument @var{len} specifies the number of elements in
@var{v}.

The function returns @var{v} on success, or @code{NULL} on failure.

@end deftypefun

@deftypefun {char *} C_string_va_make (@w{const char *@var{first}}, @w{... /* , NULL */})

This function constructs a new string which is a concatenation of all
of the strings in the NULL-terminated list of @w{@i{char *}}
arguments. The new string is dynamically allocated and must eventually
be freed by the caller.

If @var{first} is @code{NULL}, the function returns @code{NULL}.

@end deftypefun

@deftypefun {char **} C_string_va_makevec (size_t *@var{len}, @w{... /* , NULL */})

This function accepts a pointer to an integer, @var{len}, and a
@code{NULL}-terminated list of @w{@i{char *}} arguments. It creates a string
vector from its arguments, storing the number of strings in the vector
at @var{len} if it is non-@code{NULL}.

The function returns the newly created vector on success, or @code{NULL}
on failure.

@end deftypefun

@deftypefun {char **} C_string_valist2vec (const char *@var{first}, va_list @var{vp}, size_t *@var{slen})

This function converts a variable-argument list pointer @var{vp} into a
character string vector. The size of the vector is stored at @var{slen}
if it is non-@code{NULL}. The function returns the newly created vector
on success, or @code{NULL} on failure.

@end deftypefun

@deftypefun uint_t C_string_hash (const char *@var{s}, uint_t @var{modulo})

This function hashes the string @var{s} to an unsigned integer in the
range [0, @var{modulo} - 1]. The particular algorithm used is one that
combines bitwise operators and addition on the characters in the
string. It was devised by Joe I. Williams. The function returns the hash
value on success, or @code{0} on failure (for example, if @var{s} is
@code{NULL} or empty, or if @var{modulo} is 0).

@end deftypefun

@deftypefun int C_string_compare (const void *@var{s1}, const void *@var{s2})

This function is a wrapper for the @code{strcmp()} library function. It
typecasts @var{s1} and @var{s2} to @i{char *} and passes them to
@code{strcmp()}, returning that function's return value.

This function is passed to the @code{qsort()} library function by routines
which use that function to sort strings. It is provided here for that
purpose.

@end deftypefun

@deftypefun int C_string_compare_len (@w{const char *@var{s1}}, @w{size_t @var{len1}}, @w{const char *@var{s2}}, @w{size_t @var{len2}})

This function compares two substrings, @var{s1} and @var{s2},
returning a negative value if @var{s1} is less than @var{s2}, a
positive value if @var{s1} is greater than @var{s2}, and 0 if the two
substrings are equal. At most @var{len1} and @var{len2} characters of
@var{s1} and @var{s2}, respectively, are compared.

@end deftypefun

@node String Buffer Functions, Time Functions, String Manipulation and Parsing Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section String Buffer Functions

@tindex c_strbuffer_t

The following functions and macros are provided for the manipulation of
dynamically allocated string buffers. A @dfn{string buffer} is much like
a data buffer, except that it also includes a write pointer; this write
pointer is advanced each time text is written to the buffer.

The string stored in a string buffer is always
@code{NUL}-terminated. Each of the functions below writes as much of the
requested text as possible to the string buffer, but will never attempt
to write past the end of the buffer.

The type @i{c_strbuffer_t} represents a string buffer.

@deftypefun {c_strbuffer_t *} C_strbuffer_create (size_t @var{bufsz})
@deftypefunx c_bool_t C_strbuffer_destroy (c_strbuffer_t *@var{sb})

These functions create and destroy string buffers,
respectively. @code{C_strbuffer_create()} creates a new, empty string
buffer that is @var{bufsz} bytes in size. It returns a pointer to the
newly created string buffer on success, or @code{NULL} on failure (for
example, if @var{bufsz} is less than 1).

@code{C_strbuffer_destroy()} destroys the string buffer @var{sb},
deallocating all memory associated with the buffer. It returns
@code{TRUE} on success, or @code{FALSE} on failure (for example, if
@var{sb} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_strbuffer_clear (c_strbuffer_t *@var{sb})

This function clears the string buffer @var{sb}. The buffer is reset so
that it contains an empty string. The function returns @code{TRUE} on
success and @code{FALSE} on failure (for example, if @var{sb} is
@code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_strbuffer_strcpy (c_strbuffer_t *@var{sb}, @w{const char *@var{s}})

This function copies the string @var{s} into the string buffer @var{sb},
replacing any text currently in the buffer. The function returns
@code{TRUE} on success. If the buffer could not accommodate the entire
string, or upon failure (if @var{sb} or @var{s} is @code{NULL}) the
function returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_strbuffer_strcat (c_strbuffer_t *@var{sb}, @w{const char *@var{s}})

This function concatenates the string @var{s} onto the text in the
string buffer @var{sb}. The function returns
@code{TRUE} on success. If the buffer could not accommodate the entire
string, or upon failure (if @var{sb} or @var{s} is @code{NULL}) the
function returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_strbuffer_sprintf (c_strbuffer_t *@var{sb}, @w{const char *@var{format}}, ...)

This function appends a formatted string onto the text in the string
buffer @var{sb}; the behavior is identical to that of the
@code{sprintf()} library function. The function returns @code{TRUE} if
the entire formatted string was successfully written. If the buffer
could not accommodate the entire string, or upon failure (for example,
if @var{sb} or @var{format} is @code{NULL}) the function returns
@code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_strbuffer_putc (c_strbuffer_t *@var{sb}, @w{char @var{c}})

This function appends the single character @var{c} onto the text in the
string buffer @var{sb}. The function returns @code{TRUE} if the
character was successfully written, or @code{FALSE} if the buffer is
already full or upon failure (for example, if @var{sb} is @code{NULL} or
@var{c} is @code{NUL}).

@end deftypefun

@deftypefun size_t C_strbuffer_size (c_strbuffer_t *@var{sb})

This function (which is implemented as a macro) returns the size of the
string buffer @var{sb}.

@end deftypefun

@deftypefun size_t C_strbuffer_strlen (c_strbuffer_t *@var{sb})

This function returns the length of the string in the string buffer
@var{sb}.

@end deftypefun

@deftypefun {const char *} C_strbuffer_string (c_strbuffer_t *@var{sb})

This function (which is implemented as a macro) returns a pointer to the
beginning of the string in the string buffer @var{sb}. This string is
guaranteed to be @code{NUL}-terminated.

@end deftypefun

@node Time Functions, CPU Timer Functions, String Buffer Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section Time Functions

The following functions parse and format time values.

@deftypefun c_bool_t C_time_format (@w{time_t @var{t}}, @w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{const char *@var{format}})

This function is a higher-level interface to the @code{strftime()}
library function. It formats the given time @var{t} (or the current
time, if @var{t} is 0) according to the format string @var{format}. Up to
@var{bufsz} bytes of the formatted text are written to the string
@var{buf}.

The function returns @code{TRUE} on success or @code{FALSE} on failure.

@end deftypefun

@deftypefun time_t C_time_parse (@w{const char *@var{s}}, @w{const char *@var{format}})

This function is a higher-level interface to the @code{strptime()}
library function. It parses a string representation @var{s} of a
date/time that is expected to be in the specified @var{format}. It
returns the parsed time as a @var{time_t} value on success, or
@code{(time_t)0} on failure.

@end deftypefun

@node CPU Timer Functions, String Vector Functions, Time Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section CPU Timer Functions

@tindex c_timer_t
These functions provide CPU benchmarking through the use of timers that
can be started and stopped.  The type @i{c_timer_t} represents a CPU
timer.

@deftypefun {c_timer_t *} C_timer_create (void)

This function creates a new timer. It returns a pointer to the 
new timer.

@end deftypefun

@deftypefun void C_timer_destroy (@w{c_timer_t *@var{timer}})

This function destroys the specified @var{timer}.

@end deftypefun

@deftypefun void C_timer_start (@w{c_timer_t *@var{timer}})

This function resets and starts the specified @var{timer}. To start a
timer without resetting it, use the @code{C_timer_resume()}
function. Calling this function on a timer that is already running has
no effect.

@end deftypefun

@deftypefun void C_timer_stop (@w{c_timer_t *@var{timer}})

This function stops the specified @var{timer}. A stopped timer can be
resumed with the @code{C_timer_resume()} function. Calling this function
on a timer that is not running has no effect.

@end deftypefun

@deftypefun void C_timer_resume (@w{c_timer_t *@var{timer}})

This function resumes the specified @var{timer}. Calling this function
on a timer that is already running has no effect.

@end deftypefun

@deftypefun void C_timer_reset (@w{c_timer_t *@var{timer}})

This function resets the specified @var{timer}.

@end deftypefun

@deftypefun float C_timer_user (@w{c_timer_t *@var{timer}})

This function (which is implemented as a macro) returns the amount of
user time (CPU time spent inside user space by the current thread or
process) accumulated by the specified @var{timer} in hundredths of
seconds. It is not meaningful to call this function with a timer that is
not stopped.

@end deftypefun

@deftypefun float C_timer_system (@w{c_timer_t *@var{timer}})

This function (which is implemented as a macro) returns the amount of
system time (CPU time spent inside kernel space by the current thread or
process) accumulated by the specified @var{timer} in hundredths of
seconds.  It is not meaningful to call this function with a timer that
is not stopped.

@end deftypefun

@deftypefun long C_timer_elapsed (@w{c_timer_t *@var{timer}})

This function (which is implemented as a macro) returns the amount of
elapsed (real) time accumulated by the specified @var{timer}, in
milliseconds. It is not meaningful to call this function with a timer
that is not stopped.

@end deftypefun

@deftypefun time_t C_timer_created (@w{c_timer_t *@var{timer}})

This function returns the system time at which the specified @var{timer}
was created. It is implemented as a macro.

@end deftypefun

@deftypefun c_bool_t C_timer_isrunning (@w{c_timer_t *@var{timer}})

This function returns @code{TRUE} if @var{timer} is currently running,
and @code{FALSE} otherwise. It is implemented as a macro.

@end deftypefun

@node String Vector Functions, , CPU Timer Functions, Utility Functions
@comment  node-name,  next,  previous,  up
@section String Vector Functions

@tindex c_vector_t

The following functions operate on string vectors. The @i{c_vector_t}
type is an encapsulation type for @code{NULL}-terminated character
string vectors (arrays of pointers to character arrays). Vectors are
commonly used in the UNIX system to pass lists of strings; the
@code{argv} vector passed into a program's @code{main()} function is
probably the most well-known example. Some system calls, such as the
@code{execv()} family of functions, also accept vector arguments.

@deftypefun {c_vector_t *} C_vector_start (uint_t @var{resize_rate})

This function creates a new vector. The argument @var{resize_rate} is a
value that specifies the rate at which memory for the vector backbone
will be allocated. A value of 40, for example, specifies that memory is
allocated for 40 @i{char *} pointers at a time. The smaller the value,
the more frequently memory will be reallocated (thus decreasing
performance), but the more efficient memory use will be.

On success, the function returns a pointer to the new @i{c_vector_t}
structure, which can be used as a ``handle'' in subsequent calls to the
vector manipulation functions. On failure (for example, if
@var{resize_rate} is 0), it returns @code{NULL}.

@end deftypefun

@deftypefun c_bool_t C_vector_store (c_vector_t *@var{v}, const char *@var{s})

This function ``stores'' a new string @var{s} in the vector @var{v}. If
the vector is full, it is automatically resized. Note that the string
@var{s} is not copied into the vector; only the pointer is stored in the
vector backbone. Therefore it is the responsibility of the caller to
ensure that the memory that @var{s} occupies is not volatile.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{v} or @var{s} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_vector_contains (@w{c_vector_t *@var{v}}, @w{const char *@var{s}})

This function searches for the string @var{s} in the vector
@var{v}. It returns @code{TRUE} if the string is found and
@code{FALSE} otherwise.

@end deftypefun

@deftypefun {char **} C_vector_end (c_vector_t *@var{v}, size_t *@var{len})

This function signifies that no more strings will be stored in the
vector @var{v}. The vector is @code{NULL}-terminated, the length of the
vector is stored at @var{len} if it is not @code{NULL}, and all memory
associated with the vector other than the backbone itself, including the
@i{c_vector_t} structure, is deallocated.

The function returns the vector as a pointer to an array of character
pointers on success, or @code{NULL} upon failure (for example, if
@var{v} is @code{NULL}).

@end deftypefun

@deftypefun void C_vector_abort (c_vector_t *@var{v})

This function aborts construction of the vector @var{v}, freeing all
memory associated with the vector, including the @var{c_vector_t}
structure and the vector backbone.

@end deftypefun

@defmac C_vector_free (v)

This is a convenience macro. It is identical to @code{C_free_vec()}.

@end defmac

@node Data Structure Functions, Real-Time Scheduler Functions, String Vector Functions, Top
@comment  node-name,  next,  previous,  up
@menu
* Basic Data Types::
* B-Trees::
* Linked Lists::
* Queues::
* Stacks::
* Hashtables::
* Dynamic Arrays::
* Dynamic Strings::
@end menu
@chapter Data Structure Functions

Since the ultimate purpose of every program is to manipulate data, data
structures are an integral part of any piece of software. The following
functions provide implementations of various data structures, including
linked lists, hash tables, and others. All of the constants, macros, and
functions described in this chapter are defined in the header
@file{cbase/data.h}.

@node Basic Data Types, B-Trees, , Data Structure Functions
@comment  node-name,  next,  previous,  up
@menu
* Links::
* IDs::
* Data Elements::
* Tags::
@end menu
@section Basic Data Types

@tindex c_link_t
@tindex c_tag_t

The types @i{c_link_t} and @i{c_tag_t} are used extensively by the
linked-list and hashtable functions, but are documented for their
possible use in other contexts.

@node Links, IDs, , Basic Data Types
@comment  node-name,  next,  previous,  up
@subsection Links

The type @i{c_link_t} is a structure that contains the following members:

@multitable @columnfractions .2 .7
@item @code{void *data}
@tab Pointer to link data.
@item @code{c_link_t *prev}
@tab Pointer to previous link.
@item @code{c_link_t *next}
@tab Pointer to next link.
@end multitable

@sp 1

The type @i{c_link_t} can be used in any context that requires the
chaining of data elements. New links can be created via calls to
@code{C_new()}.

@defmac C_link_data (link)
@defmacx C_link_prev (link)
@defmacx C_link_next (link)

These three macros access the corresponding fields in the link structure
@var{link}. The first macro returns a @w{@i{void *}} pointer and the other two
return pointers to @i{c_link_t} structures.

@end defmac

@node IDs, Data Elements, Links, Basic Data Types
@comment  node-name,  next,  previous,  up
@subsection IDs

@tindex c_id_t

The type @i{c_id_t} represents a non-negative integer ID. It is defined
as an @i{unsigned long long}, a 64-bit unsigned integer.

@node Data Elements, Tags, IDs, Basic Data Types
@comment  node-name,  next,  previous,  up
@subsection Data Elements

@tindex c_datum_t

The type @i{c_datum_t} represents a data element with an ID. It is a
structure that contains the following members:

@multitable @columnfractions .2 .7
@item @code{c_id_t key}
@tab The key.
@item @code{void * data}
@tab Pointer to data.
@end multitable

@sp 1

The type @i{c_datum_t} can be used in any context that requires data
elements to be tagged with a numeric key. New data elements can be
created via calls to @code{C_new()}.

@defmac C_datum_key (@var{datum})
@defmacx C_datum_value (@var{datum})

These two macros access the corresponding fields in the datum structure
@var{datum}. The first macro returns a @i{c_id_t} value and the second
returns a @i{void *} pointer.

@end defmac

@node Tags, , Data Elements, Basic Data Types
@comment  node-name,  next,  previous,  up
@subsection Tags

The type @i{c_tag_t} is a structure that contains the following members:

@multitable @columnfractions .2 .7
@item @code{char *key}
@tab Pointer to key string.
@item @code{void *data}
@tab Pointer to data.
@end multitable

@sp 1

This type can be used in any context that requires the
labelling of a data element with a string. New tags can be created via
calls to @code{C_new()}.

@defmac C_tag_key (tag)
@defmacx C_tag_data (tag)

These two macros access the corresponding fields in the tag structure
@var{tag}. The first macro returns a @w{@i{void *}} pointer and the
second returns a @w{@i{char *}} pointer.

@end defmac

@node B-Trees, Linked Lists, Basic Data Types, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section B-Trees

@tindex c_btree_t

The following functions operate on b-trees. A @dfn{b-tree} is a special
type of balanced tree in which each node has at most @var{n} data
elements and @w{@var{n} + 1} children, for some even value of
@var{n}. The value of @var{n} is the @dfn{order} of the b-tree, and is
specified at the time the b-tree is created. B-trees are balanced and
sorted, to provide for very efficient lookup, even in the case of a
b-tree that contains tens of thousands of elements.

The type @i{c_btree_t} represents a b-tree.

@deftypefun {c_btree_t *} C_btree_create (uint_t @var{order})
@deftypefunx void C_btree_destroy (@w{c_btree_t *@var{tree}})

These functions create and destroy b-trees. @code{C_btree_create()}
creates a new, empty b-tree of order @var{order} (which must be at least
2) and returns a pointer to the new tree on success, or @code{NULL} on
failure.

@code{C_btree_destroy()} frees all memory associated with the b-tree
@var{tree}. If a destructor has been specified for the b-tree, all user
data is destroyed as well using that destructor.

@end deftypefun

@deftypefun c_bool_t C_btree_set_destructor (@w{c_btree_t *@var{tree}}, @w{void (*@var{destructor})(void *)})

This function sets the destructor for the b-tree @var{tree}. The
function @var{destructor} will be called for each element that is
deleted from the b-tree as a result of a call to @code{C_btree_delete()}
or @code{C_btree_destroy()}; a pointer to the data element being
destroyed will be passed to the destructor.  A value of @code{NULL} may
be passed to remove a previously installed destructor.

There is no default destructor; if no destructor is set for the b-tree,
user data will not be automatically freed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{tree} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_btree_store (@w{c_btree_t *@var{tree}}, @w{c_id_t @var{key}}, @w{const void *@var{data}})
@deftypefunx {void *} C_btree_restore (@w{c_btree_t *@var{tree}}, @w{c_id_t @var{key}})

These functions store data in and restore data from the b-tree @var{tree}.

@code{C_btree_store()} stores a new datum with the specified @var{key}
and data value @var{data} in the b-tree. The function returns
@code{TRUE} on success or @code{FALSE} on failure (for example, if
@var{tree} or @var{data} is @code{NULL}, or if the b-tree already
contains a datum with the specified @var{key}).

@code{C_btree_restore()} returns a pointer to the data value of the
datum whose key is @var{key} in the b-tree. If an element with the
specified @var{key} does not exist in the tree, or upon failure (for
example, if @var{key} is @code{0} or @var{tree} is @code{NULL}), the
function returns @code{NULL}.

@end deftypefun

@deftypefun c_bool_t C_btree_delete (@w{c_btree_t *@var{tree}}, @w{c_id_t @var{key}})

This function deletes the data element with the specified @var{key} from
the b-tree @var{tree}. It returns @code{TRUE} on success or @code{FALSE}
on failure (for example, if @var{tree} is @code{NULL}, if @var{key} is
@code{0}, or if an element with the specified @var{key} does not exist in the
b-tree).

@end deftypefun

@deftypefun c_bool_t C_btree_iterate (@w{c_btree_t *@var{tree}}, @w{c_bool_t (*@var{consumer})(void *elem, void *hook)}, @w{void *@var{hook}})

This function is a generic iterator for b-trees. It performs a
breadth-first traversal of the b-tree @var{tree}. For each node in the
tree, it calls the user-supplied function @var{consumer}(), passing to
it a pointer to the element, and the pointer @var{hook} (which can be
used to pass around state information). The @var{consumer}() function is
expected to return @code{TRUE} as long as traversal should continue; if
it returns @code{FALSE}, or when the entire tree has been traversed,
this function exits, returning @code{FALSE} in the former case, or
@code{TRUE} in the latter.

@end deftypefun

@deftypefun uint_t C_btree_order (@w{c_btree_t *@var{tree}})

This function returns the order of the b-tree @var{tree}. It is
implemented as a macro.

@end deftypefun

@node Linked Lists, Queues, B-Trees, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Linked Lists

@tindex c_linklist_t

The following functions operate on linked lists, which are constructed
from @i{c_link_t} structures. A linked list is a chain of elements in
which each element has a link to the element before it and the element
after it. These functions do not store actual data; they merely organize
pointers to data into a linked list structure. It is up to the caller to
allocate and manage memory for the data.

A @dfn{link pointer} is associated with each linked list. The link
pointer is like a bookmark in the list---it points to one of the links in
the list, and can be moved around within the list. The link pointer
simplifies the task of @dfn{list traversal}. This link pointer is stored
inside the linked list data structure itself.

In some cases, data corruption may result if two threads simultaneously
call functions that adjust the link pointer in a list, or if a function
that is traversing a list calls another function that, as a side effect,
moves the link pointer of that list. In these cases, use the reentrant
forms of the functions below, which end in an @samp{_r} suffix. Rather
than using the link pointer within the list itself, these functions use
a link pointer supplied by the caller.

Linked lists are useful in a very wide variety of contexts---too many,
indeed, to list here.

The type @i{c_linklist_t} represents a linked list.
@page
@deftypefun {c_linklist_t *} C_linklist_create (void)
@deftypefunx void C_linklist_destroy (c_linklist_t *@var{l})

These functions create and destroy linked lists. @code{C_linklist_create()}
allocates memory for a new, empty linked list and returns a pointer to
the new list on success, or @code{NULL} on failure.

@code{C_linklist_destroy()} frees all memory associated with the linked
list @var{l}. If a destructor has been specified for the list, all user
data is destroyed as well using that destructor.

@end deftypefun

@deftypefun c_bool_t C_linklist_set_destructor (c_linklist_t *@var{l}, @w{void (*@var{destructor})(void *)})

This function sets the destructor for the linked list @var{l}. The
function @var{destructor} will be called for each element that is
deleted from the linked list as a result of a call to
@code{C_linklist_delete()}, @code{C_linklist_delete_r()}, or
@code{C_linklist_destroy()}; a pointer to the data element being
destroyed will be passed to the destructor.  A value of @code{NULL} may
be passed to remove a previously installed destructor.

There is no default destructor; if no destructor is set for the linked
list, user data will not be automatically freed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{l} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_linklist_store (c_linklist_t *@var{l}, @w{const void *@var{data}})
@deftypefunx {void *} C_linklist_restore (c_linklist_t *@var{l})

These functions store data in and restore data from the linked list
@var{l}.

@code{C_linklist_store()} creates a new link which points to @var{data}
and stores it in the linked list @var{l} at the current position of the
list's link pointer (see @code{C_linklist_move()}). Note that the data
at @var{data} is not duplicated; only the pointer is copied into the
linked list. The new link is always inserted before the link that the
link pointer points to. If the link pointer is set to @code{NULL}, then
the new link is inserted after the tail of the list, and hence becomes
the new tail. The function returns @code{TRUE} on success or
@code{FALSE} on failure (for example, if @var{l} or @var{data} is
@code{NULL}).

@code{C_linklist_restore()} returns a pointer to the data element of the
link at the current position of @var{l}'s link pointer. On failure (for
example, if @var{l} is @code{NULL}, or if the link pointer is pointing
past the end of the list) the function returns @code{NULL}.

@end deftypefun

@deftypefun c_bool_t C_linklist_prepend (c_linklist_t *@var{l}, @w{const void *@var{data}})
@deftypefunx c_bool_t C_linklist_append (c_linklist_t *@var{l}, @w{const void *@var{data}})

These functions work similarly to @code{C_linklist_store()}, described
above, except that they store the new element at the beginning or the
end of the list, respectively. The list's link pointer is not modified
as a result of either of these calls.

@end deftypefun

@deftypefun c_bool_t C_linklist_store_r (@w{c_linklist_t *@var{l}}, @w{const void *@var{data}}, @w{c_link_t **@var{p}})
@deftypefunx {void *} C_linklist_restore_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})

These are reentrant versions of the functions @code{C_linklist_store()}
and @code{C_linklist_restore()} described above. They both accept an
additional argument, @var{p}, which is the address of the link pointer
to be used.

@end deftypefun

@deftypefun c_bool_t C_linklist_delete (@w{c_linklist_t *@var{l}})

This function deletes the link at the linked list @var{l}'s link
pointer. It returns @code{TRUE} on success or @code{FALSE} on failure
(for example, if @var{l} is @code{NULL} or if the link pointer points
past the end of the list). The link pointer is adjusted to point to the
link following the link that was deleted (or to @code{NULL} if the tail
was deleted).

@end deftypefun

@deftypefun c_bool_t C_linklist_delete_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})

This is the reentrant version of the function @code{C_linklist_delete()}
described above. It accepts an additional argument, @var{p}, which is
the address of the link pointer to be used.

@end deftypefun

@deftypefun c_bool_t C_linklist_search (c_linklist_t *@var{l}, @w{const void *@var{data}})

This function searches the linked list @var{l} from beginning to end for
a link whose data member is @var{data}. (Comparison is done by comparing
the data pointers only.) If the item is found, the link pointer is left
pointing to the matched link and the function returns
@code{TRUE}. Otherwise, it returns @code{FALSE}.

@end deftypefun

@deftypefun c_bool_t C_linklist_search_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})

This is the reentrant version of the function @code{C_linklist_search()}
described above. It accepts an additional argument, @var{p}, which is
the address of the link pointer to be used.

@end deftypefun

@deftypefun c_bool_t C_linklist_move (c_linklist_t *@var{l}, int @var{where})
@deftypefunx c_bool_t C_linklist_move_head (c_linklist_t *@var{l})
@deftypefunx c_bool_t C_linklist_move_tail (c_linklist_t *@var{l})
@deftypefunx c_bool_t C_linklist_move_next (c_linklist_t *@var{l})
@deftypefunx c_bool_t C_linklist_move_prev (c_linklist_t *@var{l})
@deftypefunx c_bool_t C_linklist_move_end (c_linklist_t *@var{l})

These functions move the linked list @var{l}'s link pointer. The link
pointer affects where data will be stored in the list and whence data
will be restored from the list.

@vindex C_LINKLIST_HEAD
@vindex C_LINKLIST_TAIL
@vindex C_LINKLIST_NEXT
@vindex C_LINKLIST_PREV
@vindex C_LINKLIST_END
@code{C_linklist_move()} moves @var{l}'s link pointer to the location
specified by @var{where}, which can have one of the following values:
@code{C_LINKLIST_HEAD}, @code{C_LINKLIST_TAIL},
@code{C_LINKLIST_NEXT}, @code{C_LINKLIST_PREV},
@code{C_LINKLIST_END}. These values move the link pointer to the head,
tail, next link, previous link, or end of the list, respectively. Calls to
move to the head or to the tail always succeed, returning @code{TRUE}
(unless @var{l} is @code{NULL}). Calls to move to the next or previous
link return @code{TRUE} if a link exists in the specified direction,
or @code{FALSE} if such movement would move the pointer off either end
of the list (or if @var{l} is @code{NULL}).

The link pointer may become @code{NULL} as a result of this call; this
signifies that it is pointing just past the end of the linked list, and
therefore subsequent calls to @code{C_linklist_restore()} will return
@code{NULL}. This is useful for traversing lists.

The five convenience functions @code{C_linklist_move_head()},
@code{C_linklist_move_tail()}, @code{C_linklist_move_next()},
@code{C_linklist_move_prev()}, and @code{C_linklist_move_end()}
automatically pass the appropriate values for @var{where} to
@code{C_linklist_move()}. They are implemented as macros.

The following example illustrates a @code{for} loop that iterates
through a linked list of strings:

@example
c_linklist_t *list;
void *data;

for(C_linklist_move_head(list);
    (data = C_linklist_restore(list)) != NULL;
    C_linklist_move_next(list))
  printf("Data: %s\n", (char *)data);
@end example

@end deftypefun

@deftypefun c_bool_t C_linklist_move_r (@w{c_linklist_t *@var{l}}, @w{int @var{where}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_move_head_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_move_tail_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_move_next_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_move_prev_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_move_end_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})

These are the reentrant versions of the @code{C_linklist_move()} family
of functions described above. They each accept an additional argument,
@var{p}, which is the address of the link pointer to be used.

@end deftypefun

@deftypefun c_bool_t C_linklist_ishead (@w{c_linklist_t *@var{l}})
@deftypefunx c_bool_t C_linklist_istail (@w{c_linklist_t *@var{l}})
@deftypefunx c_bool_t C_linklist_isend (@w{c_linklist_t *@var{l}})

These functions (which are implemented as macros) test the linked list
@var{l}'s link pointer to determine if it is at the head, tail, or end
of the list. They return @code{TRUE} if so and @code{FALSE}
otherwise.

@end deftypefun

@deftypefun c_bool_t C_linklist_ishead_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_istail_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})
@deftypefunx c_bool_t C_linklist_isend_r (@w{c_linklist_t *@var{l}}, @w{c_link_t **@var{p}})

These are the reentrant versions of the functions
@code{C_linklist_ishead()}, @code{C_linklist_istail()}, and
@code{C_linklist_isend()}, described above. They each accept an
additional argument, @var{p}, which is the address of the link pointer
to be used.

@end deftypefun

@deftypefun {c_link_t *} C_linklist_head (c_linklist_t *@var{l})
@deftypefunx {c_link_t *} C_linklist_tail (c_linklist_t *@var{l})

These functions (which are implemented as macros) return the head and
tail link, respectively, of the linked list @var{l}. A return value of
@code{NULL} indicates that the list is empty.

@end deftypefun

@deftypefun size_t C_linklist_length (c_linklist_t *@var{l})

This function (which is implemented as a macro) returns the length of
the linked list @var{l}, that is, the number of links in the list.

@end deftypefun

@node Queues, Stacks, Linked Lists, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Queues

@tindex c_queue_t

A queue is a FIFO (first in, first out) data structure with a beginning
and an end. Items are enqueued onto the end of the list and dequeued
from the beginning. These functions do not store actual data; they
merely organize pointers to data into a linked list structure. It is up
to the caller to allocate and manage memory for the data.

Queues are useful in producer/consumer contexts, where data items must
be processed in the order that they are received, and where new items
may potentially arrive more quickly than they can be processed.

The type @i{c_queue_t} represents a queue.

@deftypefun {c_queue_t *} C_queue_create (void)
@deftypefunx void C_queue_destroy (c_queue_t *@var{q})

These functions create and destroy queues. @code{C_queue_create()}
allocates memory for a new, empty queue and returns a pointer to the new
queue on success, or @code{NULL} on failure.

@code{C_queue_destroy()} frees all memory associated with the queue
@var{q}. If a destructor has been specified for the queue, all user data
is destroyed as well using that destructor.

@end deftypefun

@deftypefun c_bool_t C_queue_set_destructor (c_queue_t *@var{q}, @w{void (*@var{destructor})(void *)})

This function sets the destructor for the queue @var{q}. The function
@var{destructor} will be called for each element that is deleted from
the queue as a result of a call to @code{C_queue_destroy()}; a pointer
to the data element being destroyed will be passed to the destructor.  A
value of @code{NULL} may be passed to remove a previously installed
destructor.

There is no default destructor; if no destructor is set for the queue,
user data will not be automatically freed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{q} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_queue_enqueue (c_queue_t *@var{q}, @w{const void *@var{data}})
@deftypefunx {void *} C_queue_dequeue (c_queue_t *@var{q})

These functions enqueue data onto and dequeue data from the queue
@var{q}. @code{C_queue_enqueue()} enqueues @var{data} as a new item at
the end of the queue. It returns @code{TRUE} on success, or @code{FALSE}
on failure (for example, if @var{q} or @var{data} is @code{NULL}).

@code{C_queue_dequeue()} dequeues an item from the beginning of the
queue, returning a pointer to the dequeued data on success, or
@code{NULL} on failure (for example, if @var{q} is @code{NULL} or
empty).

@end deftypefun

@deftypefun size_t C_queue_length (c_queue_t *@var{q})

This function (which is implemented as a macro) returns the length of
the queue @var{q}, that is, the number of items in the queue.

@end deftypefun

@node Stacks, Hashtables, Queues, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Stacks

@tindex c_stack_t

The following functions operate on stacks. A stack is a LIFO (last in,
first out) data structure with a top and a bottom. Items are pushed onto
or popped off the top of the stack. These functions do not store actual
data; they merely organize pointers to data into a stack structure. It
is up to the caller to allocate and manage memory for the data.

Stacks are useful in a variety of contexts, most typically in parsers
and interpreters.

The type @i{c_stack_t} represents a stack.

@deftypefun {c_stack_t *} C_stack_create (void)
@deftypefunx void C_stack_destroy (c_stack_t *@var{s})

These functions create and destroy stacks. @code{C_stack_create()}
allocates memory for a new, empty stack and returns a pointer to the new
stack on success, or @code{NULL} on failure.

@code{C_stack_destroy()} frees all memory associated with the stack
@var{s}. If a destructor has been specified for the stack, all user data
is destroyed as well using that destructor.

@end deftypefun

@deftypefun c_bool_t C_stack_set_destructor (c_stack_t *@var{s}, @w{void (*@var{destructor})(void *)})

This function sets the destructor for the stack @var{s}. The function
@var{destructor} will be called for each element that is deleted from the
stack as a result of a call to @code{C_stack_destroy()}; a pointer to
the data element being destroyed will be passed to the destructor.  A
value of @code{NULL} may be passed to remove a previously installed
destructor.

There is no default destructor; if no destructor is set for the stack,
user data will not be automatically freed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{s} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_stack_push (c_stack_t *@var{s}, @w{const void *@var{data}})
@deftypefunx {void *} C_stack_pop (c_stack_t *@var{s})

These functions push data onto and pop data off the stack @var{s}.
@code{C_stack_push()} pushes @var{data} onto the top of the stack. It
returns @code{TRUE} on success, or @code{FALSE} on failure (for example,
if @var{s} or @var{data} is @code{NULL}).

@code{C_stack_pop()} pops the topmost item off the stack. It returns the
popped data on success, or @code{NULL} on failure (for example, if
@var{s} is @code{NULL} or empty).

@end deftypefun

@deftypefun {void *} C_stack_peek (c_stack_t *@var{s})

This function returns the topmost item on the stack @var{s}, without
removing the item from the stack as does @code{C_stack_pop()}. A return
value of @code{NULL} indicates that the stack is empty.

@end deftypefun

@deftypefun size_t C_stack_depth (c_stack_t *@var{s})

This function (which is implemented as a macro) returns the depth of the
stack @var{s}, that is, the number of items on the stack.

@end deftypefun

@node Hashtables, Dynamic Arrays, Stacks, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Hashtables

@tindex c_hashtable_t

The following functions operate on hashtables. A hashtable is
implemented as an array of @i{n} linked lists of tags, where @i{n} is
the number of buckets in the hashtable. These functions do not store
actual data; they merely organize pointers to data into a hashtable
structure. It is up to the user to allocate and manage memory for the
data.

Hashtables are typically used as data dictionaries; a data item is
tagged with a unique string and then stored in the hashtable. This
unique string, or @dfn{key}, is subsequently used to retrieve that data
item.

Items are stored in a hashtable as follows. First, a hashing algorithm
is used to convert the item's key to an integer between 0 and @i{n} -
1, where @i{n} is the number of buckets in the hashtable. The item is
then placed in the appropriate bucket. Each bucket is implemented as a
linked list of items.

An item lookup consists of hashing the desired key to an integer,
selecting the appropriate bucket, and then doing a linear search through
the items in that bucket, comparing keys until the desired item is
found.

Item lookup in a hashtable is faster than in a linked list or other
similar data structure. The maximum number of comparisons required to
find an item in a hashtable is equal to the number of items in the
longest linked list in the hashtable. Increasing the number of buckets
will decrease the number of collisions in the hashtable; that is, the
likelihood that any two keys will hash to the same value (and fall into
the same bucket) will be reduced. This will result in less items in each
bucket and hence shorter linked lists to search through.

The type @i{c_hashtable_t} represents a hashtable.

@deftypefun {c_hashtable_t *} C_hashtable_create (uint_t @var{buckets})
@deftypefunx void C_hashtable_destroy (c_hashtable_t *@var{h})

These functions create and destroy hashtables, respectively.

@code{C_hashtable_create()} creates a new, empty hashtable with the
specified number of @var{buckets}. It returns a pointer to the new
hashtable structure on success, or @code{NULL} on failure (for example,
if @var{buckets} is 0). The larger the value for @var{buckets}, the more
efficient a table lookup will be; values less than 10 are generally not
useful.

@code{C_hashtable_destroy()} frees all memory associated with the
hashtable @var{h}. If a destructor has been specified for the hash
table, all user data is destroyed as well using that destructor.

@end deftypefun

@deftypefun c_bool_t C_hashtable_set_destructor (c_hashtable_t *@var{h}, @w{void (*@var{destructor})(void *)})

This function sets the destructor for the hashtable @var{h}. The
function @var{destructor} will be called for each element that is
deleted from the hashtable as a result of a call to
@code{C_hashtable_delete()} or @code{C_hashtable_destroy()}; a pointer
to the data element being destroyed will be passed to the destructor.  A
value of @code{NULL} may be passed to remove a previously installed
destructor.

There is no default destructor; if no destructor is set for the
hashtable, user data will not be automatically freed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{h} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_hashtable_store (c_hashtable_t *@var{h}, @w{const char *@var{key}}, @w{const void *@var{data}})
@deftypefunx {void *} C_hashtable_restore (c_hashtable_t *@var{h}, @w{const char *@var{key}})

These functions store data in and restore data from the hashtable @var{h}.

@code{C_hashtable_store()} creates a new tag with the given @var{key}
and @var{data}, hashes @var{key}, and uses the hash value as an index
into the array of linked lists in the hashtable. It then inserts the tag
at the head of the appropriate linked list. Note that this function does
not actually copy data into the hashtable; it only stores the pointer
@var{data} in the appropriate linked list in the hashtable. The function
returns @code{TRUE} on success, or @code{FALSE} on failure (for example,
if @var{h} or @var{key} is @code{NULL}).

@code{C_hashtable_restore()} searches the hashtable for a tag whose key
matches @var{key}. It does this by hashing @var{key}, selecting the
appropriate linked list in the hashtable, and then doing a linear search
in that linked list to find the desired element. The function returns a
pointer to the matching tag's data field if a match is found, or
@code{NULL} if no match was found or if @var{h} or @var{key} is
@code{NULL}.

@end deftypefun

@deftypefun c_bool_t C_hashtable_delete (c_hashtable_t *@var{h}, @w{const char *@var{key}})

This function searches for a tag whose key matches @var{key} in the same
manner as @code{C_hashtable_restore()}, and removes the matching tag
from the table.

The function returns @code{TRUE} on success, or @code{FALSE} if no match
was found or if @var{h} or @var{key} is @code{NULL}.

@end deftypefun

@deftypefun {char **} C_hashtable_keys (@w{c_hashtable_t *@var{h}}, @w{size_t *@var{len}})

This function returns all of the keys in the hashtable @var{h} as a
string vector. If @var{len} is not @code{NULL}, the length of the vector
is stored at @var{len}. If @var{h} is @code{NULL}, the function returns
@code{NULL}. The returned vector is dynamically allocated and must
eventually be freed by the caller.

@end deftypefun

@deftypefun c_bool_t C_hashtable_set_hashfunc (uint_t (*@var{func})(@w{const char *s}, @w{uint_t modulo}))

This function allows the user to specify an alternate hashing function
@var{func}. The default hashing function is
@code{C_string_hash()}. @var{func}() must accept a string and a modulo
value and return an unsigned integer in the range [0, @code{modulo} -
1]. This function stores the pointer @var{func}() in a static area
within the library for use in subsequent calls to the hashtable
functions. The function returns @code{TRUE} on success, or @code{FALSE}
if @var{func}() is @code{NULL}.

@end deftypefun

@deftypefun size_t C_hashtable_size (c_hashtable_t *@var{h})

This function (which is implemented as a macro) returns the size of the
hashtable @var{h}; that is, the number of elements stored in the table.

@end deftypefun

@node Dynamic Arrays, Dynamic Strings, Hashtables, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Dynamic Arrays

@tindex c_darray_t

The following functions manipulate dynamic arrays. A dynamic array is
like a regular array: it is a contiguous segment of memory that stores a
series of equally-sized elements. Unlike with regular arrays, the user
does not have control over where in the array an element will be
stored. A new element is stored in the first free slot available, and
the index of this slot is returned to the caller. This index is used
to restore the element from the array. Memory management for dynamic
arrays is done automatically; as an array begins to fill up, it is resized
to accommodate more elements.

As elements are deleted from the array, the array does not shrink
because to periodically defragment an array while maintaining the
relative order of elements within it is inefficient.  Instead, a deleted
element is marked as an empty slot in the array, and is filled by a
subsequent store operation. If an array becomes heavily fragmented, it
may be defragmented via a call to @code{C_darray_defragment()}.

Dynamic arrays have the interesting property that they can be quickly
written to and read from a file. Since no pointers are used, the data in
the array is easily relocatable.

Dynamic arrays are intended for use in applications which generate a
database that grows steadily in size over time---a database in which
deletions are much less frequent than inserts.

The type @i{c_darray_t} represents a dynamic array.

@deftypefun {c_darray_t *} C_darray_create (uint_t @var{resize_rate}, @w{size_t @var{elemsz}})
@deftypefunx void C_darray_destroy (c_darray_t *@var{a})

These functions create and destroy dynamic arrays.

@vindex C_DARRAY_MAX_RESIZE
@code{C_darray_create()} creates a new dynamic array for elements of
size @var{elemsz} bytes. The argument @var{resize_rate} specifies the
rate at which the array will be resized. Specifically, when space in the
dynamic array is exhausted, it will be resized to make space for
@var{resize_rate} * 8 more elements. Larger values for @var{resize_rate}
will increase performance (since memory reallocation will be less
frequent), but will decrease the efficiency with which memory is
used. The function returns a pointer to the new dynamic array on
success, or @code{NULL} on failure (for example, if @var{elemsz} is 0 or
if @var{resize_rate} is less than 1 or greater than
@code{C_DARRAY_MAX_RESIZE}.

@code{C_darray_destroy()} frees all memory associated with the dynamic
array @var{a}. This includes memory occupied by data stored in the
array.

@end deftypefun

@deftypefun {void *} C_darray_store (c_darray_t *@var{a}, @w{const void *@var{data}}, @w{uint_t *@var{index}})
@deftypefunx {void *} C_darray_restore (c_darray_t *@var{a}, @w{uint_t @var{index}})

These functions store data in and restore data from the dynamic array
@var{a}.

@code{C_darray_store()} copies the element pointed to by @var{data}
(which is assumed to be of the correct size for this dynamic array) into
the array @var{a}, resizing the array if necessary. The caller will have
to typecast @var{data} to @i{void *} before passing it to this
function. The index into the array at which the element was stored is
stored at @var{index} if it is not @code{NULL}. The function returns a
pointer to the beginning of the element within the array on success, or
@code{NULL} on failure (for example, if @var{a} or @var{data} is
@code{NULL}). The caller will have to typecast this return value back to
the correct type before accessing its contents. If the caller does not
need to modify the element immediately after it is stored, it may choose
to ignore the return value and only remember the value at @var{index}
for future retrievals.

@code{C_darray_restore()} locates the element at the index @var{index}
within the array @var{a}, returning a pointer to the beginning of the
element on success, or @code{NULL} on failure (for example, if the
specified index points to an ``empty'' element, if @var{index} is out of
range, or if @var{a} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_darray_delete (c_darray_t *@var{a}, @w{uint_t @var{index}})

This function marks as ``empty'' the element whose index is @var{index}
in the array @var{a}, effectively deleting it from the array. Subsequent
calls to @code{C_darray_restore()} using this index will return
@code{NULL} until the free slot is refilled.

@end deftypefun

@deftypefun {c_darray_t *} C_darray_load (const char *@var{path})
@deftypefunx c_bool_t C_darray_save (c_darray_t *@var{a}, @w{const char *@var{path}})

These functions read dynamic arrays from and write dynamic arrays to the
file specified by @var{path}.

@code{C_darray_load()} reads a dynamic array from a file, and returns a
pointer to the loaded array on success, or @code{NULL} if
the load failed (for example, if @var{path} does not exist or is not
readable).

@code{C_darray_save()} writes the dynamic array @var{a} to a file,
returning @code{TRUE} on success, or @code{FALSE} on failure (for
example, if @var{a} is @code{NULL} or @var{path} could not be opened for
writing). If the write fails, a partially-written file may exist as a
result of this call.

The format of the file is binary; it consists of an image of the
@i{c_darray_t} structure, followed by a free-list bitstream, followed by a
contiguous block of elements. A dynamic array file should not be
modified directly.

@end deftypefun

@deftypefun {c_darray_t *} C_darray_defragment (c_darray_t *@var{a})

This function defragments the dynamic array @var{a} while preserving the
relative order of the elements within the array. This is done by
creating a new dynamic array, copying all non-deleted elements from
@var{a} to the new array, and then destroying the old array. The
function returns a pointer to the new array on success. On failure,
@code{NULL} is returned (for example, if @var{a} is @code{NULL}). If
there are no deleted elements in @var{a}, the function returns @var{a}
unmodified. Note that defragmentation of the array results in a shifting
of elements within it; therefore references to particular elements via
@w{@i{void *}} pointers or index offsets may become invalidated.

@end deftypefun

@deftypefun c_bool_t C_darray_iterate (c_darray_t *@var{a}, c_bool_t (*@var{iter})(@w{void *elem}, @w{uint_t index}, @w{void *hook}), @w{uint_t @var{index}}, @w{void *@var{hook}})

This function is a generic iterator for dynamic arrays. For each
non-deleted element in the array @var{a} beginning at the index
@var{index}, it calls the user-supplied function @var{iter}(), passing
to it a pointer to the beginning of the element, the @code{index} of the
element within the dynamic array, and the pointer @var{hook} (which can
be used to pass around state information). The @var{iter}() function is
expected to return @code{TRUE} as long as traversal should continue; if
it returns @code{FALSE}, or when the entire array has been traversed,
this function exits, returning @code{FALSE} in the former case, or
@code{TRUE} in the latter.

@end deftypefun

@deftypefun size_t C_darray_size (c_darray_t *@var{a})

This function (which is implemented as a macro) returns the size of the
dynamic array @var{a}, that is, the number of non-deleted elements in
the array.

@end deftypefun

@node Dynamic Strings, , Dynamic Arrays, Data Structure Functions
@comment  node-name,  next,  previous,  up
@section Dynamic Strings

@tindex c_dstring_t

Dynamic strings inherit many of the semantics of random-access files. A
dynamic string is a segment of memory which can be written to and read
from as if it were a normal ASCII file. The string is resized
automatically when data is written past the end of the string or when
the string is truncated to a specific length. A dynamic string has a
seek pointer that can be moved back and forth, much like the seek
pointer in a file. Like dynamic arrays, dynamic strings can be written
to and read from disk.

The type @i{c_dstring_t} represents a dynamic string.

@deftypefun {c_dstring_t *} C_dstring_create (uint_t @var{blocksz})
@deftypefunx {char *} C_dstring_destroy (c_dstring_t *@var{d})

These functions create and destroy dynamic strings.

@vindex C_DSTRING_MIN_BLOCKSZ
@code{C_dstring_create()} creates a new dynamic string with the
specified block size @var{blocksz}. The block size determines the rate
at which memory will be reallocated as the string grows and shrinks. The
larger the block size, the less frequently memory reallocation will take
place, but the more inefficient memory use will be. The function returns
a pointer to the new dynamic string on success, or @code{NULL} on
failure (for example, if @var{blocksz} is less than
@code{C_DSTRING_MIN_BLOCKSZ}). Specifically, memory will be allocated and
deallocated in increments of @var{blocksz} bytes. Therefore, if frequent
writes of long strings are anticipated, @var{blocksz} should be
sufficiently large, and if infrequent writes of long strings or frequent
writes of short strings are anticipated, @var{blocksz} should be
smaller.

@code{C_dstring_destroy()} deallocates all memory associated with the
dynamic string @var{d}, not including the string itself. This string is
@code{NUL} terminated and the function returns a pointer to it. On
failure, @code{NULL} is returned (for example, if @var{d} is
@code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_dstring_putc (c_dstring_t *@var{d}, char @var{c})
@deftypefunx c_bool_t C_dstring_puts (c_dstring_t *@var{d}, @w{const char *@var{s}})
@deftypefunx c_bool_t C_dstring_puts_len (c_dstring_t *@var{d}, @w{const char *@var{s}}, @w{size_t @var{len}})

These functions write data to the dynamic string @var{d} at the current
location of the string's seek pointer. @code{C_dstring_putc()} writes
the single character @var{c} (which cannot be @code{NUL}),
@code{C_dstring_puts()} writes the string @var{s}, and
@code{C_dstring_puts_len()} writes exactly @var{len} characters from the
string @var{s}.  All three functions update the seek pointer to point
immediately past the last character written. If the data to be written
would go past the end of the string, the string is automatically resized
to accommodate it.

The functions return @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{d} or @var{s} is @code{NULL}, if @var{len} is less
than 1, or if @var{c} is @code{NUL}).

@end deftypefun

@deftypefun char C_dstring_getc (c_dstring_t *@var{d})
@deftypefunx {char *} C_dstring_gets (c_dstring_t *@var{d}, @w{char *@var{s}}, @w{size_t @var{len}}, @w{char @var{termin}})

These functions read data from the dynamic string @var{d} starting at the
current location of the seek pointer.

@code{C_dstring_getc()} reads a single character and moves the seek
pointer forward one character. The function returns the character read
on success, or @code{NUL} if the seek pointer is already at the end of
the string or if @var{d} is @code{NULL}.

@code{C_dstring_gets()} reads characters into @var{s} until @var{len} -
1 characters have been read or the @var{termin} character is
encountered, whichever occurs first. The buffer @var{s} is
unconditionally @code{NUL} terminated; if the terminator character is
encountered, it is discarded and replaced by @code{NUL} in @var{s}. The
seek pointer is updated to point immediately past the last character
read. The function returns @var{s} on success, or @code{NULL} on failure
(for example, if the seek pointer is already at the end of the string,
if @var{d} is @code{NULL}, or if @var{len} is 0).

@end deftypefun
@page
@deftypefun c_bool_t C_dstring_seek (c_dstring_t *@var{d}, @w{unsigned long @var{where}}, @w{int @var{whence}})
@deftypefunx c_bool_t C_dstring_ungetc (c_dstring_t *@var{d})
@deftypefunx c_bool_t C_dstring_rewind (c_dstring_t *@var{d})
@deftypefunx c_bool_t C_dstring_append (c_dstring_t *@var{d})

@vindex C_DSTRING_SEEK_REL
@vindex C_DSTRING_SEEK_ABS
@vindex C_DSTRING_SEEK_END
@code{C_dstring_seek()} moves the seek pointer for the dynamic string
@var{d}. The argument @var{where} specifies the relative or absolute
number of characters by which the pointer should be moved. The argument
@var{whence} specifies how the @var{where} argument should be
interpreted. A value of @code{C_DSTRING_SEEK_REL} signifies that
@var{where} is a relative offset from the seek pointer's current
position (and may be positive or negative). A value of
@code{C_DSTRING_SEEK_ABS} specifies that @var{where} is an absolute
offset from the beginning of the dynamic string (and must be
positive). A value of @code{C_DSTRING_SEEK_END} specifies that
@var{where} is an absolute offset from the end of the dynamic string
toward the beginning (and must be positive as well). The function
returns @code{TRUE} on success, or @code{FALSE} on failure (for example,
if the new seek position would be out of range, or if @var{d} is
@code{NULL}, or if the value of @var{whence} is invalid).

@code{C_dstring_ungetc()} moves the seek pointer back one character,
@code{C_dstring_rewind()} moves it to the beginning of the dynamic
string, and @code{C_dstring_append()} moves it to the end. These
functions are implemented as macros, and their return values are the
same as those for the @code{C_dstring_seek()} function.

@end deftypefun

@deftypefun c_bool_t C_dstring_trunc (c_dstring_t *@var{d}, @w{off_t @var{length}})

This function truncates the dynamic string @var{d} to a length of
@var{size} characters. The new size must be less than or equal to the
current size; a dynamic string cannot be lengthened using this
function. The function also moves the seek pointer to the end of the
dynamic string after the truncation is performed.

The function returns @code{TRUE} on success, or @code{FALSE} on failure
(for example, if @var{d} is @code{NULL} or if @var{size} is greater than
the current length of the dynamic string).

@end deftypefun

@deftypefun {c_dstring_t *} C_dstring_load (const char *@var{path}, @w{uint_t @var{blocksz}})
@deftypefunx c_bool_t C_dstring_save (c_dstring_t *@var{d}, @w{const char *@var{path}})

These functions read dynamic strings from and write dynamic strings to the
file specified by @var{path}.

@code{C_dstring_load()} reads a dynamic string into memory. The meaning
of @var{blocksz} is the same as in @code{C_dstring_create()}; it
specifies the resize rate for the new string. On success, the function
returns a pointer to the loaded dynamic string. On
failure, it returns @code{NULL} (for example, if @var{blocksz} is
greater than @code{C_DSTRING_MAX_BLOCKSZ}, if @var{d} is @code{NULL}, or
if @var{path} does not exist or could not read).

@code{C_dstring_save()} writes the dynamic string @var{d} to a file. It
returns @code{TRUE} on success, or @code{FALSE} on failure (for example,
if @var{d} is @code{NULL} or if @var{path} could not be written). If the
save fails, a partially written file may exist as a result of this call.

The format of a dynamic string file is plain ASCII. It is simply a file
containing the string. It is safe to modify dynamic string files
directly. This implies that plain ASCII files can be created with a text
editor and then read in as dynamic strings.

@end deftypefun

@deftypefun off_t C_dstring_length (c_dstring_t *@var{d})

This function returns the length (in characters) of the dynamic string
@var{d}. It is implemented as a macro.

@end deftypefun

@node Real-Time Scheduler Functions, IPC Functions, Data Structure Functions, Top
@comment  node-name,  next,  previous,  up
@menu
* Scheduler Control Functions::
* Event Scheduling Functions::
@end menu
@chapter Real-Time Scheduler Functions

This chapter describes an implementation of a real-time scheduler whose
functionality is very similiar to that of the UNIX @i{cron} daemon.

The scheduler allows events to be scheduled in real time. As with
@i{cron}, events can be scheduled for specific dates and times. An
event can be scheduled to fire only once or repetitively depending on
a date and time specification.

Date and time specifications are made in the same manner as in
@i{crontab} files. A specification consists of five fields separated by
whitespace or colons (:). These fields specify integer patterns for
matching minute, hour, day of month, month of year, and day of week, in
that order. Each of the patterns may be either an asterisk (*), which
denotes a wildcard that matches all acceptable values, or a list of
elements separated by commas (,), where each element is either a single
integer value or a range of values denoted by a pair of integers
separated by a dash (-).

Values for minute must range from 0-59, for hour from 0-23, for day of
month from 1-31, for month of year from 1-12, and for day of week from
0-6 with 0 denoting Sunday.

Following are some example specifications and their meanings:

@example
0 0 5,15 * 1-5
@end example

Midnight on the 5th and 15th of every month, but never on a Saturday or
Sunday.

@example
15 3 * * 0-4,6
@end example

3:15 am every day except Fridays.

@example
0 * * 1 *
@end example

Every hour, on the hour, in January.

When a scheduled event fires, the user-supplied handler function is
invoked; it receives a pointer to the event structure as an
argument. This callback mechanism allows arbitrary code to be executed
at specific dates and times.

All of the functions described in this chapter are defined in the header
@file{cbase/sched.h}.

@node Scheduler Control Functions, Event Scheduling Functions, , Real-Time Scheduler Functions
@comment  node-name,  next,  previous,  up
@section Scheduler Control Functions

The following functions control the event scheduler. Due to
idiosyncrasies inherent in UNIX signal handling, the scheduler can only
be used on a per-process basis, and hence these functions are not
threadsafe. When used in a multithreaded application, calls to these
functions should be protected by a mutex lock.

@deftypefun c_bool_t C_sched_init (void)
@deftypefunx c_bool_t C_sched_shutdown (void)

These functions initialize and shut down the real-time scheduler.

@code{C_sched_init()} initializes the real-time scheduler. The current
disposition of the real-time signal @code{SIGRTMIN} is saved in static
storage within the library, and is then reassigned to call the scheduler's
internal event handler. The function returns @code{TRUE} on success, or
@code{FALSE} on failure (for example, if the scheduler has already been
initialized).

@code{C_sched_shutdown()} shuts down the real-time scheduler. The
scheduler is deactivated, and the disposition of the real-time signal
@code{SIGRTMIN} is restored. All events being managed by this scheduler
are then deactivated via calls to
@w{@code{C_sched_event_deactivate()}}. The function returns @code{TRUE}
on success, or @code{FALSE} on failure (for example, if the scheduler
was not initialized).

@end deftypefun

@deftypefun void C_sched_poll (void)

With the single-threaded version of the library, a program must
periodically poll the scheduler to allow events to be fired at their
scheduled times. This function is provided for that purpose. It
enumerates all of the registered events and fires any that are due at
the time of the call. Since the scheduling granularity is one minute,
this function must be called exactly once per minute to ensure proper
scheduler behavior.

In the multi-threaded version of the library, the scheduler runs in a
dedicated thread, hence this function is a no-op and should not be used.

@end deftypefun

@node Event Scheduling Functions, ,  Scheduler Control Functions, Real-Time Scheduler Functions
@comment  node-name,  next,  previous,  up
@section Event Scheduling Functions

@tindex c_schedevt_t

The following functions manipulate scheduler events, which are
represented by the type @i{c_schedevt_t}.

@deftypefun {c_schedevt_t *} C_sched_event_create (@w{const char *@var{timespec}}, @w{c_bool_t @var{once}}, @w{void *@var{hook}}, @w{void (*@var{handler})(c_schedevt_t *, time_t)}, @w{void (*@var{destructor})(c_schedevt_t *)}, @w{uint_t @var{id}})
@deftypefunx c_bool_t C_sched_event_destroy (@w{c_schedevt_t *@var{e}})

These functions create and destroy scheduler
events. @w{@code{C_sched_event_create()}} creates a new scheduler
event. The date/time specification string is passed as
@var{timespec}. The flag @var{once} specifies whether the event should
fire once or multiple times; if @var{once} is @code{TRUE}, the scheduler
will deactivate the event via a call to
@w{@code{C_sched_event_deactivate()}} immediately after the first time
it fires. The pointer @var{hook} may be used to attach arbitrary user
data to the event structure; this data may be retrieved using the
function @w{@code{C_sched_event_data()}}, described below. The argument
@var{handler} is a pointer to a handler function that will be invoked
when the event fires; the event structure itself, and the time at which
the event fired (as a @i{time_t} value) will be passed to the handler
upon its invocation. The argument @var{destructor} is a pointer to an
optional destructor function which should be called when this event is
deactivated via a call to @w{@code{C_sched_event_deactivate()}}. Either
or both of @var{handler} and @var{destructor} may be @code{NULL}, but a
@code{NULL} value for @var{handler} is not useful. The parameter
@var{id} is a numeric ID to assign to the event.

The function returns a pointer to the newly created event structure on
success, or @code{NULL} on failure (for example, if @var{timespec} is an
invalid specification string).

@code{C_sched_event_destroy()} destroys the scheduler event @var{e}. All
memory associated with the event (not including any user-supplied data)
is deallocated. The function returns @code{TRUE} on success, or
@code{FALSE} on failure (for example, if @var{e} is @code{NULL}).

@end deftypefun

@deftypefun c_bool_t C_sched_event_activate (@w{c_schedevt_t *@var{e}})
@deftypefunx c_bool_t C_sched_event_deactivate (@w{c_schedevt_t *@var{e}})

These functions activate and deactive the scheduler event
@var{e}.

@w{@code{C_sched_event_activate()}} activates the event @var{e}
by adding it to the scheduler's event list. The function returns
@code{TRUE} on success, or @code{FALSE} on failure (for example, if
@var{e} is @code{NULL}, or is already in the scheduler's event list).

@code{C_sched_event_deactivate()} deactivates the event @var{e} by
removing it from the scheduler's event list. If a destructor function
was specified for this event when it was created via
@w{@code{C_sched_event_create()}}, that function is invoked with @var{e}
as an argument. The function returns @code{TRUE} on success, or
@code{FALSE} on failure (for example, if @var{e} is @code{NULL}, or is
not in the scheduler's event list).

@end deftypefun

@deftypefun {c_schedevt_t *} C_sched_event_find (@w{uint_t @var{id}})

This function searches for a scheduler event with ID @var{id} in the
scheduler's event list. It returns a pointer to the matching event
structure on success, or @code{NULL} on failure.

@end deftypefun

@deftypefun {void *} C_sched_event_data (@w{c_schedevt_t *@var{e}})

This function (which is implemented as a macro) returns the user-data
for the scheduler event @var{e}.

@end deftypefun

@deftypefun uint_t C_sched_event_id (@w{c_schedevt_t *@var{e}})

This function (which is implemented as a macro) returns the ID for the
scheduler event @var{e}.

@end deftypefun

@node IPC Functions, Networking Functions, Real-Time Scheduler Functions, Top
@comment  node-name,  next,  previous,  up
@menu
* File Descriptor Passing Functions::
* Semaphore Functions::
* Shared Memory Functions::
* Signal Handling Functions::
* Terminal Functions::
@end menu
@chapter IPC Functions

``IPC'' refers to @dfn{Inter-Process Communications}, a set of mechanisms
provided by UNIX to facilitate collaboration between processes. Shared
memory, semaphores, signals, and pseudoterminals are some of the most
commonly used IPC mechanisms.

All of the constants, macros, and functions described in this chapter
are defined in the header @file{cbase/ipc.h}.

@node File Descriptor Passing Functions, Semaphore Functions, , IPC Functions
@comment  node-name,  next,  previous,  up
@section File Descriptor Passing Functions

The following functions provide a means of passing file descriptors
between unrelated processes. File descriptors (and other types of
descriptors, depending on the system) may be passed over stream pipes. A
``stream pipe'' refers to a STREAMS-based full duplex pipe or, more
commonly, a UNIX-domain socket.

@deftypefun c_bool_t C_fd_send (@w{int @var{sd}}, @w{int @var{fd}})

This function sends the file descriptor @var{fd} over the stream pipe
@var{sd}. It returns @code{TRUE} on success or @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_fd_recv (@w{int @var{sd}}, @w{int *@var{fd}})

This function receives a file descriptor over the stream pipe @var{sd},
storing the received descriptor at @var{fd}. It returns @code{TRUE} on
success or @code{FALSE} on failure.

@end deftypefun

@node Semaphore Functions, Shared Memory Functions, File Descriptor Passing Functions, IPC Functions
@comment  node-name,  next,  previous,  up
@section Semaphore Functions

@tindex c_sem_t

The following functions provide a simple API to POSIX semaphores, which
are counting semaphores. A @dfn{counting semaphore} is a simple
synchronization mechanism that can be used to coordinate the actions of
multiple processes or threads. A process or thread @i{waits} for a
semaphore, acquires the semaphore, performs some task, and then
@i{posts} the semaphore, thereby releasing it.

The initial value of the semaphore, which is a positive integer,
specifies how many instances of a resource are being guarded. For
example, if the initial value is 2, then at most two threads or
processes can lock the semaphore at a time. A semaphore created with an
initial value of 1 is called a @i{binary semaphore} and is essentially
the same as a mutex---it can be used to guard a single instance of a
resource or to protect critical sections of code.

The type @i{c_sem_t} represents a counting semaphore.

@deftypefun {c_sem_t *} C_sem_create (@w{const char *@var{name}}, @w{mode_t @var{mode}}, @w{uint_t @var{value}})
@deftypefunx void C_sem_destroy (@w{c_sem_t *@var{sem}})

@vindex C_SEM_MAX_VALUE
These functions create and destroy semaphores. @code{C_sem_create()}
initializes a new semaphore with the specified symbolic @var{name} and
initial value of @var{value}. The POSIX standard specifies that
@var{name} must begin with a slash character (`@code{/}') and may
contain no other slash characters. For best portability, the length of
@var{name} should not exceed 14 characters. The initial @var{value} must
be an integer between 1 and @code{C_SEM_MAX_VALUE}.

If the underlying POSIX semaphore object with the specified @var{name}
did not already exist, it is created. This new object is created with
world, group, and owner access permission as specified by the @var{mode}
parameter.

The function returns a pointer to the new semaphore on success, or
@code{NULL} on failure.

@code{C_sem_destroy()} destroys the semaphore @var{sem}. If no other
processes are using this semaphore, the underlying POSIX semaphore
object is destroyed.

@end deftypefun

@deftypefun c_bool_t C_sem_wait (@w{c_sem_t *@var{sem}})
@deftypefunx c_bool_t C_sem_trywait (@w{c_sem_t *@var{sem}})

These functions wait on the semaphore @var{sem}. @code{C_sem_wait()}
waits for the semaphore, blocking the calling process or thread until
the semaphore is acquired. @code{C_sem_trywait()} attempts to acquire
the semaphore, returning immediately if it cannot be locked.

Both functions return @code{TRUE} if the semaphore was successfully
acquired and @code{FALSE} otherwise.

@end deftypefun

@deftypefun c_bool_t C_sem_post (@w{c_sem_t *@var{sem}})

This function posts the semaphore @var{sem}. It returns @code{TRUE} if
the semaphore was successfully released and @code{FALSE} otherwise.

@end deftypefun

@deftypefun {const char *} C_sem_name (@w{c_sem_t *@var{sem}})

This function (which is implemented as a macro) returns the symbolic
name of the semaphore @var{sem}.

@end deftypefun

@deftypefun int C_sem_value (@w{c_sem_t *@var{sem}})

This function returns the ``current'' value of the semaphore
@var{sem}. The returned value may or may not be the actual semaphore
value at the time that the function returns; it is only guaranteed to
have been current at some point during the call.

On success, the function returns the current value of the semaphore. On
failure, it returns -1.

@end deftypefun

@deftypefun uint_t C_sem_initial_value (@w{c_sem_t *@var{sem}})

This function (which is implemented as a macro) returns the initial
value with which the semaphore @var{sem} was created.

@end deftypefun

@node Shared Memory Functions, Signal Handling Functions, Semaphore Functions, IPC Functions
@comment  node-name,  next,  previous,  up
@section Shared Memory Functions

@tindex c_shmem_t

The following functions provide a simple API to POSIX shared memory
objects. A shared memory segment is simply an arbitrary block of memory
that is mapped into more than one process's address space; data written
to the shared memory by one process is immediately visible to all other
processes that have mapped that segment. It is the fastest and most
flexible form of IPC.

The type @i{c_shmem_t} represents a shared memory segment.

@deftypefun {c_shmem_t *} C_shmem_create (@w{const char *@var{name}}, @w{size_t @var{size}}, @w{mode_t @var{mode}})

This function creates a new shared memory segment with the specified
symbolic @var{name} and size in bytes, @var{size}. The POSIX standard
specifies that @var{name} must begin with a slash character (`@code{/}')
and may contain no other slash characters. For best portability, the
length of @var{name} should not exceed 14 characters. The size of the
segment will be rounded up to the nearest system page size as reported
by @code{sysconf()}.

If the underlying POSIX shared memory object with the specified
@var{name} did not already exist, it is created, and the memory in the
segment is zeroed. The new object is created with world, group,
and owner access permission as specified by the @var{mode} parameter.

The function returns a pointer to the new @i{c_shmem_t} structure on
success, or @code{NULL} on failure. The function @code{C_shmem_base()}
may be used to obtain a pointer to the shared memory block itself.

@end deftypefun

@deftypefun void C_shmem_destroy (@w{c_shmem_t *@var{mem}})

This function destroys the shared memory segment @var{mem}. The memory
is unmapped from the calling process's address space. If no other
processes have this segment mapped, the underlying POSIX shared memory
object is destroyed. Finally, the @var{mem} structure itself is
deallocated.

@end deftypefun

@deftypefun {void *} C_shmem_base (@w{c_shmem_t *@var{mem}})

This function (which is implemented as a macro) returns a pointer to the
base of the shared memory segment @var{mem}.

@end deftypefun

@deftypefun size_t C_shmem_size (@w{c_shmem_t *@var{mem}})

This function (which is implemented as a macro) returns the size, in
bytes, of the shared memory segment @var{mem}.

@end deftypefun

@deftypefun c_bool_t C_shmem_resize (@w{c_shmem_t *@var{mem}}, @w{size_t @var{size}})

This function resizes the shared memory segment @var{mem} to a new size
of @var{size}. The requested size will be rounded up to the nearest
system page size as reported by @code{sysconf()}.

The function returns @code{TRUE} on success or @code{FALSE} on failure.

@end deftypefun

@deftypefun {const char *} C_shmem_name (@w{c_shmem_t *@var{mem}})

This function (which is implemented as a macro) returns the symbolic
name of the shared memory segment @var{mem}.

@end deftypefun

@node Signal Handling Functions, Terminal Functions, Shared Memory Functions, IPC Functions
@comment  node-name,  next,  previous,  up
@section Signal Handling Functions

The following function converts signal IDs to names.

@deftypefun {const char *} C_signal_name (int @var{sig})

This function returns a string representation of the signal specified by
@var{sig}, or @code{NULL} if @var{sig} does not refer to a known signal.

@end deftypefun

@node Terminal Functions, , Signal Handling Functions, IPC Functions
@comment  node-name,  next,  previous,  up
@menu
* Terminal Control Functions::
* Pseudoterminal Control Functions::
@end menu
@section Terminal Functions

The following functions operate on terminals and
pseudoterminals. Interactive programs such as mail readers and editors
run on terminals, but sometimes it is useful to control an interactive
program with another program. An IPC mechanism known as a
@dfn{pseudoterminal} can be used for this purpose. A pseudoterminal
appears to be a normal terminal to the slave process, and as a FIFO pipe
to the master process. The master process feeds input to and receives
input from the slave process through the pipe, and the slave process
reads from and writes to its terminal as it would normally.

These functions are not reentrant.

@node Terminal Control Functions, Pseudoterminal Control Functions, , Terminal Functions
@comment  node-name,  next,  previous,  up
@subsection Terminal Control Functions

The following functions operate on UNIX file descriptors which are
assumed to refer to terminal (tty) lines.

@deftypefun c_bool_t C_tty_raw (int @var{fd})

This function puts the terminal associated with the file descriptor
@var{fd} into @i{raw mode}. Once in this mode, the terminal driver does
not do any buffering or processing of input or output. The current
terminal settings for @var{fd} are stored in a static buffer inside the
library, and may be restored via a call to @code{C_tty_unraw()}.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_ENOTTY
@vindex C_ETCATTR
@multitable @columnfractions .2 .7
@item @code{C_ENOTTY}
@tab @var{fd} does not refer to a terminal.
@item @code{C_ETCATTR}
@tab The call to @code{tcgetattr()} or @code{tcsetattr()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_tty_unraw (int @var{fd})

This function undoes the changes to the attributes of the terminal
associated with the file descriptor @var{fd} that resulted from the
latest call to @code{C_tty_raw()}. The terminal attributes are restored
to what they were just before the call to @code{C_tty_raw()}.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_ENOTTY
@vindex C_ETCATTR
@vindex C_EINVAL
@multitable @columnfractions .2 .7
@item @code{C_ENOTTY}
@tab @var{fd} does not refer to a terminal.
@item @code{C_ETCATTR}
@tab The call to @code{tcsetattr()} failed.
@item @code{C_EINVAL}
@tab There was no previous call to @code{C_tty_raw()}.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_tty_store (int @var{fd})

This function stores the current attributes of the terminal associated
with the file descriptor @var{fd} in a static buffer inside the
library. These attributes can later be restored via a call to
@code{C_tty_restore()}. The function is useful when a terminal's
attributes must be modified from their original values temporarily by a
program, or when the attributes of one terminal must be copied to
another terminal (or to a pseudoterminal).

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_ENOTTY
@vindex C_ETCATTR
@multitable @columnfractions .2 .7
@item @code{C_ENOTTY}
@tab @var{fd} does not refer to a terminal.
@item @code{C_ETCATTR}
@tab The call to @code{tcgetattr()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_tty_restore (int @var{fd})

This function restores the terminal attributes saved with the latest
call to @code{C_tty_store()}, applying them to the terminal associated
with the file descriptor @var{fd}.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_ENOTTY
@vindex C_ETCATTR
@vindex C_EINVAL
@multitable @columnfractions .2 .7
@item @code{C_ENOTTY}
@tab @var{fd} does not refer to a terminal.
@item @code{C_ETCATTR}
@tab The call to @code{tcgetattr()} failed.
@item @code{C_EINVAL}
@tab There was no previous call to @code{C_tty_store()}.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_tty_sane (int @var{fd})

This function sets the attributes on the terminal associated with the
file descriptor @var{fd} to sane (default) values. Specifically, the
@i{input} flag word is set to @code{(ICRNL | IXON | IXOFF)}, the
@i{output} flag word is set to @code{(OPOST)}, the @i{control} flag word
is set to @code{(CREAD | HUPCL)}, and the @i{functions} flag word is set
to @code{(ECHO | ECHOE | ECHOK | ICANON | ISIG | IEXTEN)}. The control
characters are set to the following ASCII values: @code{VEOF} = 4,
@code{VEOL} = 28, @code{VERASE} = 8, @code{VINTR} = 21, @code{VKILL} =
3, @code{VQUIT} = 255, @code{VSUSP} = 255, @code{VSTART} = 17,
@code{VSTOP} = 19.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_ENOTTY
@vindex C_ETCATTR
@multitable @columnfractions .2 .7
@item @code{C_ENOTTY}
@tab @var{fd} does not refer to a terminal.
@item @code{C_ETCATTR}
@tab The call to @code{tcsetattr()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_tty_getsize (@w{uint_t *@var{columns}}, @w{uint_t *@var{rows}})

This function determines the size of the terminal, in characters. If
successful, it stores the number of columns and rows (lines) at
@var{columns} and @var{rows}, respectively, and returns @code{TRUE}. On
failure, it leaves the values at @var{columns} and @var{rows}
unmodified and returns @code{FALSE}.

@end deftypefun

@node Pseudoterminal Control Functions, , Terminal Control Functions, Terminal Functions
@comment  node-name,  next,  previous,  up
@subsection Pseudoterminal Control Functions

@tindex c_pty_t

The following functions provide an interface to System V or BSD
pseudoterminals. A pseudoterminal consists of a master and a slave; the
child process reads from and writes to the slave device as if it were a
``real'' terminal, and the parent process reads from and writes to the
child through the master device.

The type @i{c_pty_t} represents a pseudoterminal device pair.

@deftypefun {c_pty_t *} C_pty_create (void)

This function allocates a pseudoterminal from the system. On success, it
returns a pointer to the new @i{c_pty_t} structure. The functions
@code{C_pty_master_fd()} and @code{C_pty_slave_fd()}, described below,
can be used to obtain the file descriptors for the corresponding
devices. On failure, the function returns @code{NULL} and sets
@code{c_errno} to one of the following values:

@vindex C_EGETPTY
@vindex C_EOPEN
@vindex C_EIOCTL
@multitable @columnfractions .2 .7
@item @code{C_EGETPTY}
@tab The call to @code{grantpt()}, @code{unlockpt()}, or @code{ptsname()} (System V) or @code{openpty()} (BSD) failed.
@item @code{C_EOPEN}
@tab The call to @code{open()} failed.
@item @code{C_EIOCTL}
@tab The call to @code{ioctl()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_pty_destroy (c_pty_t *@var{pty})

This function closes the master and slave devices for the pseudoterminal
@var{pty} and deallocates the data structure at @var{pty}. The function
returns @code{TRUE} on success, or @code{FALSE} on failure (for example,
if @var{pty} is @code{NULL}).

@end deftypefun

@deftypefun int C_pty_master_fd (c_pty_t *@var{pty})
@deftypefunx int C_pty_slave_fd (c_pty_t *@var{pty})

These functions (which are implemented as macros) return the file
descriptors for the master and slave device, respectively, of the
pseudoterminal @var{pty}.

@end deftypefun

@deftypefun {const char *} C_pty_slave_name (c_pty_t *@var{pty})

This function (which is implemented as a macro) returns the path of the
device file for the slave device associated with the pseudoterminal
@var{pty}.

@end deftypefun

@node Networking Functions, Library Information Functions, IPC Functions, Top
@comment  node-name,  next,  previous,  up
@menu
* Network Information Functions::
* Socket Control Functions::
* Socket Multicast Functions::
* Socket I/O Functions::
@end menu
@chapter Networking Functions

This chapter describes a high-level, abstracted interface to the
Berkeley socket IPC mechanism. A @dfn{socket} is similar to a pipe, but the
two endpoints of a socket may exist on different hosts. This means that
sockets can be used to transfer data between two networked machines,
whether they are both on the same local area network, or connected to
the Internet from opposite sides of the globe.

Sockets are generally employed as a communications medium in
client/server systems. Generally, a server process creates a
@dfn{master} or @dfn{listening} socket, binds the socket to a specific
port number, and listens for connections on that socket. Clients that
know the IP address or DNS name of the host and the port number on which
the server is listening can connect to that server. Once a connection is
established, data can be easily exchanged between the server and the
client.

In the traditional model, a server typically forks a subprocess to
handle each incoming connection; otherwise the server would only be able
to service one client at a time. The subprocess communicates with the
client and exits when the connection is closed. Meanwhile, the main
server process continues to listen for new connections.

Since all of the networking functions in this library are reentrant,
they can be used to write a multithreaded server, in which one thread is
tasked with listening for new connections and spawning (or assigning) a
worker thread for each incoming connection.

As anyone who has written network code in UNIX knows, the socket
functions provide a very low-level and cumbersome networking API. The
complexity of the API is inherent in its flexibility, but in general
only a subset of the available functions and flags are
used. Furthermore, networking code is very similar across many
servers. This library greatly simplifies the development of networked
applications by hiding most of this complexity.

All of the constants, macros, and functions described in this chapter
are defined in the header @file{cbase/net.h}.

Most of the functions described below return boolean or integer
values. On failure, they return @code{FALSE} or @code{-1}, respectively, and
set the global variable @code{c_errno} to reflect the type of error. The
error codes are defined in the header file @file{cbase/cerrno.h}. Some of the
error codes indicate that a system call or socket library function
failed; in this case, the @code{errno} variable can be examined to get
the system-defined error code.

Note that in the threaded version of the library, @code{c_errno} is
defined as a macro that returns a thread-specific error value.

@node Network Information Functions, Socket Control Functions, , Networking Functions
@comment  node-name,  next,  previous,  up
@section Network Information Functions

The following functions can be used to obtain information about network
services (namely, those listed in the @file{/etc/services} file), and to
resolve IP addresses into DNS names.

@deftypefun in_port_t C_net_get_svcport (const char *@var{name}, @w{uint_t *@var{type}})

@vindex C_NET_TCP
@vindex C_NET_UDP
@vindex C_NET_UNKNOWN
@vindex C_NET_OTHER
This function looks up the port number for the service named
@var{name}. The value at @var{type} specifies which type of service to
search for. It can be one of @code{C_NET_TCP}, @code{C_NET_UDP}, or
@code{C_NET_UNKNOWN}. If the value at @var{type} is
@code{C_NET_UNKNOWN}, it is modified to reflect the actual type of the
service found; @code{C_NET_OTHER} is stored at @var{type} if the service
is neither TCP- nor UDP-based.

On success, the function returns the port number of the named
service. On failure, it returns @code{-1} and sets @code{c_errno} to one
of the following values:

@vindex C_EINVAL
@vindex C_ESVCINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{name} or @var{type} is @code{NULL}, or the value at @var{type} is invalid.
@item @code{C_ESVCINFO}
@tab The call to @code{getservbyname_r()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_net_get_svcname (in_port_t @var{port}, @w{uint_t *@var{type}}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

This function is the inverse of @code{C_net_get_svcport()}. It attempts
to find a service on the specified @var{port} of the specified
@var{type}, and writes up to @var{bufsz} - 1 bytes of the service's name
at @var{buf}. The buffer is unconditionally @code{NUL}-terminated. If
the value at @var{type} is @code{C_NET_UNKNOWN}, it is modified to
reflect the actual type of the service: @code{C_NET_OTHER} is stored at
@var{type} if the service is neither TCP- nor UDP-based.

The function returns @code{TRUE} if the service was found. On failure,
it returns @code{FALSE} and sets @code{c_errno} to one of the following
values:

@vindex C_EINVAL
@vindex C_ESVCINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{type} or @var{buf} is @code{NULL}, @var{bufsz} is 0, or the value at @var{type} is invalid.
@item @code{C_ESVCINFO}
@tab The call to @code{getservbyport_r()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_net_resolve (const char *@var{ipaddr}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

This function attempts to resolve the dot-separated IP address at
@var{ipaddr} into a valid DNS name. Up to @var{bufsz} - 1 bytes of the
resolved name are written at @var{buf}. The buffer is unconditionally
@code{NUL}-terminated.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EADDRINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{ipaddr} is @code{NULL} or is an empty string, or @var{buf} is @code{NULL}.
@item @code{C_EADDRINFO}
@tab The call to @code{inet_addr()} or @code{gethostbyaddr_r()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_net_resolve_local (char *@var{addr}, @w{char *@var{ipaddr}}, @w{size_t @var{bufsz}}, @w{in_addr_t *@var{ip}})

This function obtains the address of the local host in one or more
formats. If @var{addr} is not @code{NULL}, up to @var{bufsz} - 1 bytes
of the local host's canonical DNS name are written at @var{addr}, and
the buffer is unconditionally @code{NUL}-terminated. If @var{ipaddr} is
not @code{NULL}, up to @var{bufsz} - 1 bytes of the host's address in
the form of a dot-separated IP address are written at @var{ipaddr}, and
the buffer is unconditionally @code{NUL}-terminated. Finally, if
@var{ip} is not @code{NULL}, the local host's packed IP address is
stored at @var{ip}.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EADDRINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{addr}, @var{ipaddr}, and @var{ip} are all @code{NULL}, or @var{bufsz} is 0.
@item @code{C_EADDRINFO}
@tab The call to @code{gethostbyname_r()} failed.
@end multitable

@end deftypefun

@node Socket Control Functions, Socket Multicast Functions, Network Information Functions, Networking Functions
@comment  node-name,  next,  previous,  up
@section Socket Control Functions

@tindex c_socket_t

The following routines provide control functions, such as connecting and
disconnecting sockets, setting socket options, and obtaining socket
addresses.

The type @i{c_socket_t} represents a socket.

@deftypefun {c_socket_t *} C_socket_create (@w{int @var{type}})
@deftypefunx c_bool_t C_socket_destroy (c_socket_t *@var{s})

These two functions create and destroy sockets.

@code{C_socket_create()} creates a new socket of the specified
@var{type}. The value of @var{type} may be either @code{C_NET_TCP} (for
reliable, connection-based stream sockets) or @code{C_NET_UDP} (for
unreliable, connectionless or connection-based datagram sockets). The
function returns the newly created @i{c_socket_t} structure on
success. On failure, it returns @code{NULL} and sets @code{c_errno} to
one of the following values:

@vindex C_EINVAL
@vindex C_ESOCKET
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}, or the value of @var{type} is invalid.
@item @code{C_ESOCKET}
@tab The call to @code{socket()} failed.
@end multitable

@sp 1

@code{C_socket_destroy()} shuts down and closes the socket @var{s},
freeing all memory associated with the socket, including the
@i{c_socket_t} structure. The function will only destroy the socket if
it is created but not connected or listening, or if it has been shut
down via a call to @code{C_socket_shutdown()}. It returns @code{TRUE} on
success. On failure, it returns @code{FALSE} and sets @code{c_errno} to
one of the following values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}.
@item @code{C_EBADSTATE}
@tab The socket is not in a created or shut down state.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_create_s (@w{c_socket_t *@var{s}}, @w{int @var{type}})
@deftypefunx c_bool_t C_socket_destroy_s (@w{c_socket_t *@var{s}})

These functions are static variants of @code{C_socket_create()} and
@code{C_socket_destroy()}, respectively. They do not perform any
allocation or deallocation of @i{c_socket_t} structures, but rather
operate on pointers to preallocated structures.

@code{C_socket_create_s()} initializes the socket structure at @var{s}
as a new socket. It returns @code{TRUE} on success and @code{FALSE} on
failure.

@code{C_socket_destroy_s()} disposes the socket at @var{s}. It returns
@code{TRUE} on success and @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_socket_listen (c_socket_t *@var{s}, @w{in_port_t @var{port}})

This function binds the socket @var{s} to a local address and, if the
socket is a TCP socket, initiates listening on the specified TCP
@var{port}. It is typically used by a server process to prepare for
incoming connection requests which are subsequently accepted using
@code{C_socket_accept()}. The function may also be used with a multicast
UDP socket to notify the operating system that the socket should only
receive multicast datagrams that are destined for the specified
@var{port}. The function returns @code{TRUE} on success. On failure, it
returns @code{FALSE} and sets @code{c_errno} to one of the following
values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@vindex C_EADDRINFO
@vindex C_EBIND
@vindex C_ELISTEN
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}.
@item @code{C_EBADSTATE}
@tab The socket is not in a created state.
@item @code{C_EADDRINFO}
@tab The call to @code{gethostbyname_r()} failed.
@item @code{C_EBIND}
@tab The call to @code{bind()} failed.
@item @code{C_ELISTEN}
@tab The call to @code{listen()} failed.
@end multitable

@end deftypefun

@deftypefun {c_socket_t *} C_socket_accept (c_socket_t *@var{s})

This function accepts a pending connection request on the socket
@var{s}, returning a new socket which may be used to communicate with
the client process. If @var{s} is in a non-blocking state and no
connection is pending, the function returns immediately with a value of
@code{NULL}; otherwise, it blocks until a connection request
arrives. This new socket is created as a blocking socket and will be
connected to the client.

The function returns the newly created socket on success. On failure, it
returns @code{NULL} and sets @code{c_errno} to one of the following
values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@vindex C_EBLOCKED
@vindex C_EACCEPT
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{ns} is @code{NULL}.
@item @code{C_EBADSTATE}
@tab The socket is not in a listening state.
@item @code{C_EBLOCKED}
@tab The socket is marked as non-blocking and no connection is currently pending.
@item @code{C_EACCEPT}
@tab The call to @code{accept()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_accept_s (@w{c_socket_t *@var{s}}, @w{c_socket_t *@var{ms}})

This function is a static variant of @code{C_socket_accept()}. It does
not perform any allocation or deallocation of @i{c_socket_t} structures,
but rather operates on pointers to preallocated structures.

@code{C_socket_accept_s()} accepts a pending connection request on the
socket @var{ms} and initializes the socket structure at @var{s} as a
socket for that connection. The function returns @code{TRUE} on success
and @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_socket_connect (c_socket_t *@var{s}, @w{const char *@var{host}}, @w{in_port_t @var{port}})

This function connects the socket @var{s} to a port on a remote
host. The argument @var{host} is the address of the remote host;
it may be either a dot-separated IP address or a valid DNS name. The
argument @var{port} specifies which TCP or UDP port to connect to on the
remote host. This function is normally used by a client process that
wishes to connect to a server.

TCP sockets must be connected before they can be used to transfer data,
while UDP sockets may be used in either a connected or unconnected
state. Connecting a UDP socket binds it to a specific address, which
means that the destination address need not be specified for each
datagram sent.  Connecting a UDP socket also allows higher-level I/O
routines in this library to be used with the socket.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@vindex C_EADDRINFO
@vindex C_ENOCONN
@vindex C_ECONNECT
@vindex C_ETIMEOUT
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{host} is @code{NULL}, or @var{host} is an empty string.
@item @code{C_EBADSTATE}
@tab The socket is not in a created state.
@item @code{C_EADDRINFO}
@tab The call to @code{gethostbyaddr_r()} or @code{gethostbyname_r()} failed, most likely because @var{host} is not a valid host address.
@item @code{C_ENOCONN}
@tab The connection was refused.
@item @code{C_ECONNECT}
@tab The call to @code{connect()} failed.
@item @code{C_ETIMEOUT}
@tab The connect operation timed out.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_shutdown (c_socket_t *@var{s}, @w{uint_t @var{how}})

@vindex C_NET_SHUTRD
@vindex C_NET_SHUTWR
@vindex C_NET_SHUTALL
This function shuts down reading, writing, or reading and writing on the
socket @var{s}. The socket must be in a connected state in order to be
shut down, and it cannot be destroyed until it is in a shut down
state. The argument @var{how} specifies how the socket is to be shut
down: @code{C_NET_SHUTRD} for reading, @code{C_NET_SHUTWR} for writing,
or @code{C_NET_SHUTALL} for both reading and writing. If a socket is
shut down for writing only, then the process at the remote end of the
socket will receive an @code{EOF} if it attempts to read from
it. Conversely, if it is shut down for reading, the process at the local
end will receive an @code{EOF} if it attempts to read from it. This
function may be called repeatedly on a connected socket.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}, or the value of @var{how} is invalid.
@item @code{C_EBADSTATE}
@tab The socket is not in a connected or partially shut down state.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_get_peeraddr (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

This function obtains the address of the peer of the socket @var{s},
that is, the name of the host on the remote end of the connection. At
most @var{bufsz} - 1 bytes of the host name are written to @var{buf},
and the buffer is unconditionally @code{NUL}-terminated. The address may
either be a DNS name, such as ``ftp.uu.net'' or, if the address could not
be resolved, a dot-separated IP address, such as ``132.32.5.1''.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@vindex C_EADDRINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{buf} is @code{NULL}, or @var{bufsz} is 0.
@item @code{C_EBADSTATE}
@tab The socket is not in a connected state.
@item @code{C_EADDRINFO}
@tab The address could not be determined (the call to @code{gethostbyaddr_r()} failed).
@end multitable

@end deftypefun

@deftypefun in_addr_t C_socket_get_ipaddr (c_socket_t *@var{s})
@deftypefunx in_addr_t C_socket_get_peeripaddr (c_socket_t *@var{s})

These functions obtain the packed IP address of each end of the socket
@var{s}. @code{C_socket_get_ipaddr()} returns the IP address of the
local end of the socket, and @code{C_socket_get_peeripaddr()} returns
the IP address of the remote end of the socket. These values will only be
meaningful if the socket is in a connected state.

These functions are implemented as macros.

@end deftypefun

@deftypefun c_bool_t C_socket_fopen (c_socket_t *@var{s}, @w{int @var{buffering}})

@vindex C_NET_BUFFERING_NONE
@vindex C_NET_BUFFERING_LINE
@vindex C_NET_BUFFERING_FULL
This function opens a stream for the socket @var{s} that can be used
with the @i{stdio} library functions. The pointer to this stream may be
obtained with the @code{C_socket_get_fp()} macro. The argument
@var{buffering} specifies what type of buffering will be performed on
the new stream: @code{C_NET_BUFFERING_NONE} for no buffering,
@code{C_NET_BUFFERING_LINE} for line buffering, or
@code{C_NET_BUFFERING_FULL} for full buffering.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADSTATE
@vindex C_EBADTYPE
@vindex C_EFDOPEN
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}, or the value of @var{buffering} is invalid.
@item @code{C_EBADSTATE}
@tab The socket is not in a connected state.
@item @code{C_EBADTYPE}
@tab @var{s} is not a TCP socket.
@item @code{C_EFDOPEN}
@tab The call to @code{fdopen()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_fclose (c_socket_t *@var{s})

This function closes the @i{stdio} stream associated with the socket
@var{s}, if one has been opened via a call to @code{C_socket_fopen()}.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}.
@end multitable

@end deftypefun

@deftypefun {c_socket_t *} C_socket_reopen (int @var{sd})

This function creates a socket structure for the socket
whose descriptor is @var{sd}.

On success, the function returns the newly created @i{c_socket_t}
structure. On failure, it returns @code{NULL} and sets @code{c_errno}
to one of the following values:

@vindex C_EINVAL
@vindex C_EFCNTL
@vindex C_EBADTYPE
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{sd} is negative.
@item @code{C_EFCNTL}
@tab The call to @code{fcntl()} failed.
@item @code{C_EBADTYPE}
@tab The socket is neither a TCP nor UDP socket.
@item @code{C_ESOCKINFO}
@tab @var{sd} does not refer to a socket, or the call to @code{getpeername()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_reopen_s (@w{c_socket_t *@var{s}}, @w{int @var{sd}})

This function is a static variant of @code{C_socket_reopen()}. It does
not perform any allocation or deallocation of @i{c_socket_t} structures,
but rather operates on pointers to preallocated structures.

@code{C_socket_reopen_s()} initializes the socket structure at @var{s}
as the socket whose descriptor is @var{sd}. The function returns
@code{TRUE} on success and @code{FALSE} on failure.

@end deftypefun

@deftypefun c_bool_t C_socket_set_option (c_socket_t *@var{s}, @w{uint_t @var{option}}, @w{c_bool_t @var{flag}}, @w{uint_t @var{value}})

This function sets the option @var{option} on the socket @var{s}. Valid
options are as follows:

@vindex C_NET_OPT_BLOCK
@table @code
@item C_NET_OPT_BLOCK
Changes the blocking state on the socket. If a socket is in an unblocked
state, any I/O or control operation on the socket that would cause the
process or thread to block returns immediately with an error code of
@code{C_EBLOCKED}. Blocking is turned on if @var{flag} is @code{TRUE}
and turned off if @var{flag} is @code{FALSE}.

@vindex C_NET_OPT_LINGER
@item C_NET_OPT_LINGER
Changes the linger mode on the socket. By default, linger mode is off;
when a socket is closed and there is still data in the socket send
buffer, the operating system will attempt to deliver this data before
destroying the socket, but the close operation will return immediately. If
linger mode is turned on (@var{flag} is @code{TRUE}), the process will
be blocked for up to @var{value} seconds when it closes a socket while
the operating system attempts to deliver any pending data; any data
still not delivered after this interval (which may be 0 seconds) will be
discarded. The default setting is off.

@vindex C_NET_OPT_REUSEADDR
@item C_NET_OPT_REUSEADDR
While there are various uses for this option, the most common use is to
allow a server to bind to its port even if there are existing clients
connected to that port. The option is turned on if @var{flag} is @code{TRUE}
and turned off if @var{flag} is @code{FALSE}. The default setting is
off. The function @code{C_socket_listen()} automatically turns on this
option.

@vindex C_NET_OPT_OOBINLINE
@item C_NET_OPT_OOBINLINE
Specifies whether out-of-band data should be sent inline on the
socket. The option is turned on if @var{flag} is @code{TRUE} and turned
off if @var{flag} is @code{FALSE}. The default setting is off.

@vindex C_NET_OPT_KEEPALIVE
@item C_NET_OPT_KEEPALIVE
This option provides a means to detect if the host at the remote end of
the socket is still alive by sending a periodic TCP @i{probe}. If the
option is turned on, the operating system will terminate the connection
if the remote host does not respond to the probes. The option is turned
on if @var{flag} is @code{TRUE} and turned off if @var{flag} is
@code{FALSE}. The default setting is off.

@vindex C_NET_OPT_RECVBUF
@item C_NET_OPT_RECVBUF
Changes the size of the socket receive buffer. The argument @var{value}
specifies the new size of the receive buffer, in bytes, and must be
greater than 0. The argument @var{flag} is ignored.

@vindex C_NET_OPT_SENDBUF
@item C_NET_OPT_SENDBUF
Changes the size of the socket send buffer. The argument @var{value}
specifies the new size of the send buffer, in bytes, and must be greater
than 0. The argument @var{flag} is ignored.

@end table

This function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EFCNTL
@vindex C_EBADSTATE
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL} or the value of @var{option} is invalid.
@item @code{C_EFCNTL}
@tab The call to @code{fcntl()} failed.
@item @code{C_EBADSTATE}
@tab An attempt was made to change the blocking state on a socket that is shut down.
@item @code{C_ESOCKINFO}
@tab The call to @code{setsockopt()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_get_option (c_socket_t *@var{s}, @w{uint_t @var{option}}, @w{c_bool_t *@var{flag}}, @w{uint_t *@var{value}})

This function gets the current settings for the option @var{option} on
the socket @var{s}. The arguments @var{flag} and @var{value} are used to
store the settings for the given option; which of these arguments is
used depends on the type of option. See @code{C_socket_set_option()}
above for a description of the available options and their settings.

This function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s}, @var{flag}, or @var{value} is @code{NULL}, or the value of @var{option} is invalid.
@item @code{C_ESOCKINFO}
@tab The call to @code{getsockopt()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_block (@w{c_socket_t *@var{s}})
@deftypefunx c_bool_t C_socket_unblock (@w{c_socket_t *@var{s}})
@deftypefunx c_bool_t C_socket_isblocked (@w{c_socket_t *@var{s}})

These convenience functions change and test the blocking state on the
socket @var{s}; they are implemented as macros which evaluate to the
appropriate calls to @code{C_socket_set_option()} and
@code{C_socket_get_option()}.

@code{C_socket_block()} marks the socket @var{s} as blocking, and
@code{C_socket_unblock()} marks the socket @var{s} as
non-blocking. @code{C_socket_isblocked()} returns @code{TRUE} if the
socket is in blocking mode and @code{FALSE} if it is non-blocking.

@end deftypefun

@deftypefun int C_socket_get_fd (@w{c_socket_t *@var{s}})
@deftypefunx {FILE *} C_socket_get_fp (@w{c_socket_t *@var{s}})

These functions (which are implemented as macros) return the socket
descriptor and file stream pointer, respectively, for the socket
@var{s}. @code{C_socket_get_fp()} returns the stream pointer, if one
has been created via @code{C_socket_fopen()}; otherwise it returns
@code{NULL}.

@end deftypefun

@deftypefun int C_socket_get_type (@w{c_socket_t *@var{s}})

This function returns the type of the socket @var{s}, either
@code{C_NET_TCP} or @code{C_NET_UDP}. It is implemented as a macro.

@end deftypefun

@deftypefun void C_socket_set_timeout (@w{c_socket_t *@var{s}}, @w{int @var{sec}})
@deftypefunx int C_socket_get_timeout (@w{c_socket_t *@var{s}})

These functions set and get the I/O timeout for the socket @var{s}. They
are implemented as macros.

@code{C_socket_set_timeout()} sets the timeout to @var{sec} seconds. The
socket receive and send functions described below all return an error if
the corresponding I/O operation times out after the given number of
seconds.

@end deftypefun

@deftypefun void C_socket_set_conn_timeout (@w{c_socket_t *@var{s}}, @w{int @var{sec}})
@deftypefunx int C_socket_get_conn_timeout (@w{c_socket_t *@var{s}})

These functions set and get the connection timeout for the socket
@var{s}. They are implemented as macros.

@code{C_socket_set_conn_timeout()} sets the timeout to @var{sec}
seconds. The @code{C_socket_connect()} function will return an error if
a connection cannot be established within the specified number of
seconds. The default, system-imposed timeout of roughly 75 seconds is an
upper bound on this timeout; therefore passing values greater than 75
will not lengthen the timeout. Timeout values of 0 or less are interpreted
as an infinite timeout.

@end deftypefun

@deftypefun void C_socket_set_userdata (@w{c_socket_t *@var{s}}, @w{void *@var{data}})
@deftypefunx {void *} C_socket_get_userdata (@w{socket_t *@var{s}})

These functions set and get the ``user data'' field of the socket
@var{s}. This field is simply a pointer which can be used to attach
arbitrary data to a socket. The functions are implemented as macros.

@end deftypefun

@node Socket Multicast Functions, Socket I/O Functions, Socket Control Functions, Networking Functions
@comment  node-name,  next,  previous,  up
@section Socket Multicast Functions

These functions provide UDP multicast functionality. Multicast addresses
range from 224.0.0.0 through 239.255.255.255. A UDP datagram sent to a
multicast address is delivered to all hosts on the network which have
joined the multicast group specified by that address. Multicasting is
described in detail in chapter 19 of @i{UNIX Network Programming Volume
1} by W. Richard Stevens.

@deftypefun c_bool_t C_socket_mcast_join (@w{c_socket_t *@var{s}}, @w{const char *@var{addr}})
@deftypefunx c_bool_t C_socket_mcast_leave (@w{c_socket_t *@var{s}}, @w{const char *@var{addr}})

These functions provide a means for joining and leaving a multicast
group. @code{C_socket_mcast_join()} assigns the UDP socket @var{s} to
the multicast group specified by the address @var{addr}, which may
either be a valid DNS name or a dot-separated IP
address. @code{C_socket_mcast_leave()} removes the UDP socket @var{s}
from the multicast group specified by the address @var{addr}.

These functions return @code{TRUE} on success. On failure, they return
@code{FALSE} and set @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_EADDRINFO
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{addr} is @code{NULL}, or @var{addr} is an empty string.
@item @code{C_EBADTYPE}
@tab @var{s} is not a UDP socket.
@item @code{C_EADDRINFO}
@tab The call to @code{gethostbyaddr_r()} or @code{gethostbyname_r()} failed, most likely because @var{addr} is not a valid network address.
@item @code{C_ESOCKINFO}
@tab The call to @code{setsockopt()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_mcast_set_ttl (@w{c_socket_t *@var{s}}, @w{c_byte_t @var{ttl}})

This function sets the time-to-live value on the socket @var{s} to
@var{ttl}. It returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}.
@item @code{C_EBADTYPE}
@tab @var{s} is not a UDP socket.
@item @code{C_ESOCKINFO}
@tab The call to @code{setsockopt()} failed.
@end multitable

@end deftypefun

@deftypefun c_bool_t C_socket_mcast_set_loop (@w{c_socket_t *@var{s}}, @w{c_bool_t @var{loop}})

This function enables or disables the loopback function for the UDP
socket @var{s}. If loopback is enabled (@var{loop} is @code{TRUE}), then
any multicast datagrams that are sent out over this socket from the
local host will also be delivered back to the host. If loopback is
disabled, they are not. The loopback feature is enabled by default.

The function returns @code{TRUE} on success. On failure, it returns
@code{FALSE} and sets @code{c_errno} to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_ESOCKINFO
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} is @code{NULL}.
@item @code{C_EBADTYPE}
@tab @var{s} is not a UDP socket.
@item @code{C_ESOCKINFO}
@tab The call to @code{setsockopt()} failed.
@end multitable

@end deftypefun

@node Socket I/O Functions, , Socket Multicast Functions, Networking Functions
@comment  node-name,  next,  previous,  up
@section Socket I/O Functions

The following functions are high-level routines for reading data from
and writing data to TCP and UDP sockets.

@deftypefun int C_socket_recv (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{c_bool_t @var{oobf}})
@deftypefunx int C_socket_send (c_socket_t *@var{s}, @w{const char *@var{buf}}, @w{size_t @var{bufsz}}, @w{c_bool_t @var{oobf}})

These functions read data from and write data to the socket
@var{s}. They may be used with TCP sockets or with connected UDP
sockets. If @var{s} is a TCP socket and @var{oobf} is @code{TRUE}, the
data is read or written @i{out-of-band}.

@code{C_socket_recv()} reads up to @var{bufsz} bytes of data from the
socket @var{s} into @var{buf}. If @var{s} is a UDP socket, it attempts
to receive the data as a single datagram. If @var{s} is a TCP socket,
then the function continually loops, reading as much data as it can on
each iteration, until either the buffer has been filled, or no more data
is available for reading on the socket. If the socket is marked as
blocking, the function will block waiting for more data to arrive, and
will then continue to read the data.

@code{C_socket_send()} writes @var{bufsz} bytes of data starting at
@var{buf} to the socket @var{s}. If @var{s} is a UDP socket, it attempts
to send the buffer as a single datagram. If @var{s} is a TCP socket,
then the function continually loops, writing as much data as it can on
each iteration, until either the entire buffer has been written, or the
socket is unable to accept any more data. If the socket is marked as
blocking, the function will block waiting for it to drain, and will then
continue writing the data.

If an error or timeout occurs after @i{n} bytes of data have been read
or written, these functions return -@i{n}. If all of the data is read or
written successfully, the functions return the number of bytes read or
written (normally equal to @var{bufsz}). The functions return @code{0}
if an error occurs before any data has been read or written. On timeout
or failure, @code{c_errno} is set to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_EBADSTATE
@vindex C_ELOSTCONN
@vindex C_EBLOCKED
@vindex C_ESEND
@vindex C_ERECV
@vindex C_EMSG2BIG
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{buf} is @code{NULL}, or @var{bufsz} is 0.
@item @code{C_EBADTYPE}
@tab @var{s} is neither a TCP nor a UDP socket.
@item @code{C_EBADSTATE}
@tab The socket is not in a connected state.
@item @code{C_ELOSTCONN}
@tab The connection was lost during data transfer.
@item @code{C_EBLOCKED}
@tab The socket is marked as non-blocking and the requested transfer would block the process.
@item @code{C_ESEND}
@tab The call to @code{send()} or @code{sendto()} failed.
@item @code{C_ERECV}
@tab The call to @code{recv()} or @code{recvfrom()} failed.
@item @code{C_EMSG2BIG}
@tab @var{s} is a UDP socket, and @var{bufsz} is too many bytes to send as one datagram.
@end multitable

@end deftypefun

@deftypefun int C_socket_sendto (c_socket_t *@var{s}, @w{const char *@var{buf}}, @w{size_t @var{bufsz}}, @w{const char *@var{addr}}, @w{in_port_t @var{port}})
@deftypefunx int C_socket_recvfrom (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{char *@var{addr}}, @w{size_t @var{addrsz}})

These functions send and receive datagrams over the unconnected UDP
socket @var{s}.

@code{C_socket_sendto()} sends @var{bufsz} bytes beginning at @var{buf}
to the specified @var{port} on the remote host named
@var{addr}. @code{C_socket_recvfrom()} receives @var{bufsz} bytes from a
remote host and writes them to @var{buf}, storing up to @var{addrsz} - 1
bytes of the remote host's address at @var{addr} and unconditionally
@code{NUL}-terminates the buffer. This address is either a DNS name or,
if the address could not be resolved, a dot separated IP address.

These functions return the number of bytes written or read upon success,
@dfn{0} if the socket is marked as blocking and the operation would
block, or @code{-1} upon failure. On block or failure, @code{c_errno} is
set to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_EBADSTATE
@vindex C_EADDRINFO
@vindex C_ELOSTCONN
@vindex C_EBLOCKED
@vindex C_ESENDTO
@vindex C_ERECVFROM
@vindex C_EMSG2BIG
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{addr} is @code{NULL}, or (for @code{C_socket_sendo()}) @var{addr} is an empty string.
@item @code{C_EBADTYPE}
@tab @var{s} is not a UDP socket.
@item @code{C_EBADSTATE}
@tab The socket is not in a created state.
@item @code{C_EADDRINFO}
@tab The remote source or destination address could not be determined.
@item @code{C_ELOSTCONN}
@tab The connection was lost.
@item @code{C_EBLOCKED}
@tab The socket is marked as non-blocking and the requested operation would block.
@item @code{C_ESENDTO}
@tab The call to @code{sendto()} failed.
@item @code{C_ERECVFROM}
@tab The call to @code{recvfrom()} failed.
@item @code{C_EMSG2BIG}
@tab @var{bufsz} is too many bytes to send or receive as one datagram.
@end multitable

@end deftypefun

@deftypefun int C_socket_sendreply (c_socket_t *@var{s}, @w{const char *@var{buf}}, @w{size_t @var{bufsz}})
@deftypefunx int C_socket_recvreply (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

These functions are similar to @code{C_socket_sendto()} and
@code{C_socket_recvfrom()} above, except that they reuse the remote
address currently set for the UDP socket @var{s}. Specifically,
@code{C_socket_sendreply()} sends a buffer of data to the address from
which the last datagram was received on @var{s}, and
@code{C_socket_recvreply()} receives a buffer of data from the address
to which the last datagram was sent on @var{s}. These functions are
intended for use on unconnected UDP sockets.

On success, the functions return the number of bytes sent or
received. On failure, they return @code{-1} and set @code{c_errno} to one of
the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_EBADSTATE
@vindex C_ELOSTCONN
@vindex C_EBLOCKED
@vindex C_ESENDTO
@vindex C_ERECVFROM
@vindex C_EMSG2BIG
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{buf} or @var{s} is @code{NULL} or @var{bufsz} is 0.
@item @code{C_EBADTYPE}
@tab @var{s} is not a UDP socket.
@item @code{C_EBADSTATE}
@tab The socket is not in a created state.
@item @code{C_ELOSTCONN}
@tab The connection was lost.
@item @code{C_EBLOCKED}
@tab The socket is marked as non-blocking and the requested operation would block.
@item @code{C_ESENDTO}
@tab The call to @code{sendto()} failed.
@item @code{C_ERECVFROM}
@tab The call to @code{recvfrom()} failed.
@item @code{C_EMSG2BIG}
@tab @var{bufsz} is too many bytes to send or receive as one datagram.
@end multitable

@end deftypefun

@deftypefun int C_socket_sendline (c_socket_t *@var{s}, @w{const char *@var{buf}})
@deftypefunx int C_socket_recvline (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}})

These functions read and write ``lines'' to and from the TCP socket
@var{s}. The socket must be in blocking mode for use with these
functions.

@code{C_net_socket_sendline()} writes the data at @var{buf}, followed by
a CR+LF pair, to the socket @var{s}. The function returns when all of
the data has been written or a timeout occurs.

@code{C_net_socket_recvline()} reads data into @var{buf}. It continues
reading until @var{bufsz} - 1 bytes have been read, or a CR+LF
pair has been encountered in the input, whichever occurs first. The
CR+LF pair, if present, is discarded, and the buffer is
unconditionally @code{NUL}-terminated. The function returns when all
of the data has been read, or a timeout occurs.

If an error or timeout occurs after @i{n} bytes of data have been read
or written, these functions return -@i{n}. If all of the data was
written successfully, the functions return the number of bytes read or
written. The functions return @code{0} if an error occurs before any
data has been read or written. On timeout or failure, @code{c_errno} is
set to one of the following values:

@vindex C_EINVAL
@vindex C_EBADTYPE
@vindex C_EBADSTATE
@vindex C_ELOSTCONN
@vindex C_ETIMEOUT
@vindex C_ESEND
@vindex C_ERECV
@multitable @columnfractions .2 .7
@item @code{C_EINVAL}
@tab @var{s} or @var{buf} is @code{NULL}, or @var{bufsz} is 0.
@item @code{C_EBADTYPE}
@tab @var{s} is not a TCP socket.
@item @code{C_EBADSTATE}
@tab The socket is not in a connected state, or it is in non-blocking mode.
@item @code{C_ELOSTCONN}
@tab The connection was lost during data transfer.
@item @code{C_ETIMEOUT}
@tab A timeout occurred while waiting to read or write data.
@item @code{C_ESEND}
@tab The call to @code{send()} or @code{sendto()} failed.
@item @code{C_ERECV}
@tab The call to @code{recv()} or @code{recvfrom()} failed.
@end multitable

@end deftypefun

@deftypefun int C_socket_writeline (c_socket_t *@var{s}, @w{const char *@var{buf}}, @w{const char *@var{termin}}, @w{uint_t @var{slen}}, @w{uint_t @var{snum}})
@deftypefunx int C_socket_readline (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{char @var{termin}}, @w{uint_t @var{slen}}, @w{uint_t @var{snum}})
@deftypefunx int C_socket_rl (c_socket_t *@var{s}, @w{char *@var{buf}}, @w{size_t @var{bufsz}}, @w{char @var{termin}})
@deftypefunx int C_socket_wl (c_socket_t *@var{s}, @w{const char *@var{buf}}, @w{const char *@var{termin}})

These interfaces are deprecated, and are emulated by macros for backward
compatibility. They evaluate to calls to the @code{C_socket_sendline()}
and @code{C_socket_recvline()} functions, described above, ignoring the
@var{termin}, @var{slen}, and @var{snum} arguments.

@end deftypefun

@node Library Information Functions, References, Networking Functions, Top
@comment  node-name,  next,  previous,  up
@chapter Library Information Functions

The following functions provide runtime information about the cbase
library itself. All of the functions described in this chapter are
defined in the header @file{cbase/version.h}.


@deftypefun {const char *} C_library_version (void)

This function returns a string containing the version number of the
library. This version number corresponds to the version of the package.

@end deftypefun

@deftypefun {const char *} C_library_info (void)

This function returns a string containing information about the library,
including the package name and version, the author, bug report email
address, and copyright.

@end deftypefun

@deftypefun {const char **} C_library_options (void)

This function returns a @code{NULL}-terminated array of strings which
represent the set of options that are enabled in the
library. Currently only the following option is defined:
@samp{threaded} (if the multi-threaded version of the library is in
use).

@end deftypefun


@node References, License, Library Information Functions, Top
@comment  node-name,  next,  previous,  up
@appendix References

The following books proved to be indispensable during the implementation
of this library.

@sp 1

@itemize @bullet

@item Gallmeister, Bill O. @i{POSIX.4: Programming for the Real World}.

@item Lewine, Donald. @i{POSIX Programmer's Guide}.

@item Nichols, Bradford, et. al. @i{Pthreads Programming}.

@item Stevens, W. Richard. @i{UNIX Network Programming, Volume 1: Networking APIs: Sockets and XTI}. 2nd ed.

@item Stevens, W. Richard. @i{UNIX Network Programming, Volume 2: Interprocess Communications}. 2nd ed.

@end itemize

@node License, Function Index, References, Top
@comment  node-name,  next,  previous,  up
@appendix License

The cbase library is distributed under the terms of the LGPL. The complete
text of the license appears below.

@sp 3

@include LGPL.texi

@node Function Index, Type Index, License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@node Type Index, Symbol Index, Function Index, Top
@unnumbered Type Index

@printindex tp

@node Symbol Index, , Type Index, Top
@unnumbered Symbol Index

@printindex vr

@bye
